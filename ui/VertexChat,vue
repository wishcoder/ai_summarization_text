<template>
  <v-container class="pa-0 fill-height d-flex flex-column" fluid>
    <!-- Header -->
    <v-sheet class="px-4 py-3 border-b" elevation="0">
      <div class="text-subtitle-1 font-weight-medium">Vertex Chat</div>
    </v-sheet>

    <!-- Messages area -->
    <v-sheet
      class="flex-grow-1 overflow-auto px-3 py-4"
      elevation="0"
      ref="scrollAreaRef"
    >
      <div class="d-flex flex-column" style="gap: 12px;">
        <template v-for="m in messages" :key="m.id">
          <div
            class="d-flex"
            :class="m.sender === 'user' ? 'justify-end' : 'justify-start'"
          >
            <v-sheet
              class="pa-3 rounded-xl bubble"
              :class="m.sender === 'user' ? 'bubble-user' : 'bubble-bot'"
              elevation="1"
              max-width="80%"
            >
              <!-- Render parsed segments; link segments are clickable -->
              <template v-for="(seg, idx) in m.segments" :key="idx">
                <span v-if="seg.type === 'text'">{{ seg.text }}</span>
                <v-btn
                  v-else
                  variant="text"
                  density="compact"
                  class="text-decoration-underline px-0"
                  @click="onLinkClick((seg as LinkSegment).href)"
                >
                  {{ (seg as LinkSegment).text }}
                </v-btn>
              </template>
            </v-sheet>
          </div>
        </template>

        <!-- Typing / busy indicator bubble -->
        <div v-if="busy" class="d-flex justify-start">
          <v-sheet class="pa-3 rounded-xl bubble bubble-bot" elevation="1" max-width="60%">
            <div class="d-flex align-center" style="gap: 10px;">
              <v-progress-circular indeterminate size="18" width="2" />
              <span>Thinking…</span>
            </div>
          </v-sheet>
        </div>
      </div>
    </v-sheet>

    <!-- Divider with progress bar when busy -->
    <div class="position-relative">
      <v-divider />
      <v-progress-linear
        v-if="busy"
        absolute
        bottom
        indeterminate
        height="3"
      />
    </div>

    <!-- Input area -->
    <v-sheet class="px-3 py-2" elevation="0">
      <v-text-field
        v-model="draft"
        variant="outlined"
        density="comfortable"
        :disabled="busy"
        :placeholder="busy ? 'Please wait…' : 'Type your message…'"
        hide-details
        clearable
        @keydown.enter="trySend"
        class="ma-0"
      >
        <template #append-inner>
          <v-btn
            icon
            :disabled="busy || !canSend"
            @click="trySend"
            :aria-label="'Send message'"
          >
            <v-icon>mdi-send</v-icon>
          </v-btn>
        </template>
      </v-text-field>
    </v-sheet>
  </v-container>
</template>

<script lang="ts">
import { defineComponent, ref, computed, nextTick, type Ref } from 'vue';
import { sendQuery, processChatAction } from './VertexChat';

type Sender = 'user' | 'bot';

type TextSegment = { type: 'text'; text: string };
type LinkSegment = { type: 'link'; text: string; href: string };
type Segment = TextSegment | LinkSegment;

interface ChatMessage {
  id: string;
  sender: Sender;
  raw: string;
  segments: Segment[];
}

export default defineComponent({
  name: 'VertexChat',
  setup() {
    // --- State ---
    const messages = ref<ChatMessage[]>([]);
    const draft = ref<string>('');
    const busy = ref<boolean>(false);
    const scrollAreaRef: Ref<HTMLElement | null> = ref(null);

    const canSend = computed<boolean>(() => draft.value.trim().length > 0 && !busy.value);

    // --- Helpers ---
    function uid(): string {
      return Math.random().toString(36).slice(2, 9);
    }

    /**
     * Parse an HTML string and map <a href="..">text</a> into link segments,
     * with all other content as plain text segments.
     */
    function parseAnchorSegments(htmlish: string): Segment[] {
      const container = document.createElement('div');
      container.innerHTML = htmlish;

      const result: Segment[] = [];

      function walk(node: ChildNode) {
        if (node.nodeType === Node.TEXT_NODE) {
          const text = node.textContent ?? '';
          if (text) result.push({ type: 'text', text });
          return;
        }
        if (node.nodeType === Node.ELEMENT_NODE) {
          const el = node as HTMLElement;
          if (el.tagName.toLowerCase() === 'a') {
            const href = el.getAttribute('href') || '';
            const text = el.textContent?.trim() || href || 'link';
            result.push({ type: 'link', text, href });
            return;
          }
          Array.from(node.childNodes).forEach(walk);
        }
      }

      Array.from(container.childNodes).forEach(walk);
      return result.length ? result : [{ type: 'text', text: htmlish }];
    }

    function appendMessage(sender: Sender, raw: string) {
      messages.value.push({
        id: uid(),
        sender,
        raw,
        segments: parseAnchorSegments(raw),
      });
      scrollToBottomSoon();
    }

    function scrollToBottomSoon() {
      nextTick(() => {
        const el = scrollAreaRef.value;
        if (el) el.scrollTop = el.scrollHeight;
      });
    }

    // --- Required local function: updateResult ---
    function updateResult(response: string) {
      appendMessage('bot', response);
    }

    // --- UI Events ---
    async function trySend() {
      if (!canSend.value) return;
      const text = draft.value.trim();
      draft.value = '';

      appendMessage('user', text);

      busy.value = true;
      try {
        const response = await sendQuery(text);
        updateResult(response);
      } catch (err) {
        updateResult('Sorry, something went wrong.');
        // eslint-disable-next-line no-console
        console.error(err);
      } finally {
        busy.value = false;
      }
    }

    function onLinkClick(href: string) {
      processChatAction(href);
    }

    return {
      // state
      messages,
      draft,
      busy,
      scrollAreaRef,
      // computed
      canSend,
      // types for template casting
      // (exported so <template> can use LinkSegment type cast)
      onLinkClick,
      trySend,
    };
  },
});
</script>

<style scoped>
.fill-height {
  height: 100%;
}

.border-b {
  border-bottom: 1px solid rgba(0,0,0,0.08);
}

.bubble {
  white-space: pre-wrap; /* preserve newlines in responses */
  word-break: break-word;
}

/* Requirement 7: User chat bubble = silver background */
.bubble-user {
  background-color: silver !important;
  color: rgba(0,0,0,0.87);
}

/* Requirement 8: Response chat bubble = green background */
.bubble-bot {
  background-color: #A5D6A7 !important; /* green-ish */
  color: rgba(0,0,0,0.87);
}

.text-decoration-underline {
  text-decoration: underline;
}
</style>
