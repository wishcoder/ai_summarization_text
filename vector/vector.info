============ SQL TVF ============

-- Location: us-central1
-- Creates a table-valued function you can call like:
-- SELECT * FROM `myproj.mydata.semantic_search_all`(q => <ARRAY<FLOAT64>>, topK => 30, threshold => 0.7,
--                                                   search_incidents => TRUE, search_requests => TRUE, search_confluence => TRUE);

CREATE OR REPLACE FUNCTION `myproj.mydata.semantic_search_all`(
  q ARRAY<FLOAT64>,         -- 768-D query embedding (L2-normalized in Java to match stored vectors)
  topK INT64,               -- per-branch top_k (applied inside each VECTOR_SEARCH)
  threshold FLOAT64,        -- nullable; set NULL to disable score filtering
  search_incidents BOOL,    -- toggle Incidents
  search_requests BOOL,     -- toggle IRequests
  search_confluence BOOL    -- toggle Confluence
)
RETURNS TABLE<
  source_table STRING,
  id           STRING,
  name         STRING,
  score        FLOAT64,
  base         STRUCT<
    -- Unioned "base" schema so the TVF has a stable result type across all three sources.
    -- For rows that don't use a field, it will be NULL.
    incId                      STRING,
    incName                    STRING,
    reqId                      STRING,
    reqName                    STRING,
    idConfluence               STRING,
    nameConfluence             STRING,
    -- Paired *Text table fields (for summarization)
    error_text                 STRING,
    solution_text              STRING,
    description_text           STRING,
    notes_text                 STRING,
    confluence_data_text       STRING,
    confluence_contacts_text   STRING
  >
)
AS (
  WITH query_vec AS (SELECT q AS emb),

  -- ================== Incidents (embedding_error / embedding_solution) ==================
  inc_union AS (
    SELECT 'TableIncidents' AS source_table, base.incId AS id, base.incName AS name, distance, base
    FROM VECTOR_SEARCH(
      TABLE `myproj.mydata.TableIncidents`,
      'embedding_error',
      (SELECT emb FROM query_vec), 'emb',
      top_k => topK, distance_type => 'COSINE', options => '{}'
    )
    UNION ALL
    SELECT 'TableIncidents', base.incId, base.incName, distance, base
    FROM VECTOR_SEARCH(
      TABLE `myproj.mydata.TableIncidents`,
      'embedding_solution',
      (SELECT emb FROM query_vec), 'emb',
      top_k => topK, distance_type => 'COSINE', options => '{}'
    )
  ),
  inc_best AS (
    SELECT source_table, id, name, MIN(distance) AS best_distance
    FROM inc_union
    GROUP BY source_table, id, name
  ),
  inc_joined AS (
    SELECT
      b.source_table,
      b.id,
      b.name,
      -- Build the unioned STRUCT explicitly so schemas match across UNION ALL later.
      STRUCT(
        i.incId,
        i.incName,
        CAST(NULL AS STRING) AS reqId,
        CAST(NULL AS STRING) AS reqName,
        CAST(NULL AS STRING) AS idConfluence,
        CAST(NULL AS STRING) AS nameConfluence,
        it.embedding_error_text,
        it.embedding_solution_text,
        CAST(NULL AS STRING) AS description_text,
        CAST(NULL AS STRING) AS notes_text,
        CAST(NULL AS STRING) AS confluence_data_text,
        CAST(NULL AS STRING) AS confluence_contacts_text
      ) AS base,
      LEAST(GREATEST(1.0 - b.best_distance, 0.0), 1.0) AS score
    FROM inc_best b
    JOIN `myproj.mydata.TableIncidents` i
      ON i.incId = b.id
    LEFT JOIN `myproj.mydata.TableIncidentsText` it
      ON it.incId = b.id
  ),

  -- ================== IRequests (embedding_description / embedding_notes) ==================
  req_union AS (
    SELECT 'TableIRequests', base.reqId, base.reqName, distance, base
    FROM VECTOR_SEARCH(
      TABLE `myproj.mydata.TableIRequests`,
      'embedding_description',
      (SELECT emb FROM query_vec), 'emb',
      top_k => topK, distance_type => 'COSINE', options => '{}'
    )
    UNION ALL
    SELECT 'TableIRequests', base.reqId, base.reqName, distance, base
    FROM VECTOR_SEARCH(
      TABLE `myproj.mydata.TableIRequests`,
      'embedding_notes',
      (SELECT emb FROM query_vec), 'emb',
      top_k => topK, distance_type => 'COSINE', options => '{}'
    )
  ),
  req_best AS (
    SELECT source_table, id, name, MIN(distance) AS best_distance
    FROM req_union
    GROUP BY source_table, id, name
  ),
  req_joined AS (
    SELECT
      b.source_table,
      b.id,
      b.name,
      STRUCT(
        CAST(NULL AS STRING) AS incId,
        CAST(NULL AS STRING) AS incName,
        r.reqId,
        r.reqName,
        CAST(NULL AS STRING) AS idConfluence,
        CAST(NULL AS STRING) AS nameConfluence,
        CAST(NULL AS STRING) AS error_text,
        CAST(NULL AS STRING) AS solution_text,
        rt.embedding_description_text,
        rt.embedding_notes_text,
        CAST(NULL AS STRING) AS confluence_data_text,
        CAST(NULL AS STRING) AS confluence_contacts_text
      ) AS base,
      LEAST(GREATEST(1.0 - b.best_distance, 0.0), 1.0) AS score
    FROM req_best b
    JOIN `myproj.mydata.TableIRequests` r
      ON r.reqId = b.id
    LEFT JOIN `myproj.mydata.TableIRequestsText` rt
      ON rt.reqId = b.id
  ),

  -- ================== Confluence (embedding_confluence_data / embedding_confluence_contacts) ==================
  conf_union AS (
    SELECT 'TableConfluence', base.idConfluence, base.nameConfluence, distance, base
    FROM VECTOR_SEARCH(
      TABLE `myproj.mydata.TableConfluence`,
      'embedding_confluence_data',
      (SELECT emb FROM query_vec), 'emb',
      top_k => topK, distance_type => 'COSINE', options => '{}'
    )
    UNION ALL
    SELECT 'TableConfluence', base.idConfluence, base.nameConfluence, distance, base
    FROM VECTOR_SEARCH(
      TABLE `myproj.mydata.TableConfluence`,
      'embedding_confluence_contacts',
      (SELECT emb FROM query_vec), 'emb',
      top_k => topK, distance_type => 'COSINE', options => '{}'
    )
  ),
  conf_best AS (
    SELECT source_table, id, name, MIN(distance) AS best_distance
    FROM conf_union
    GROUP BY source_table, id, name
  ),
  conf_joined AS (
    SELECT
      b.source_table,
      b.id,
      b.name,
      STRUCT(
        CAST(NULL AS STRING) AS incId,
        CAST(NULL AS STRING) AS incName,
        CAST(NULL AS STRING) AS reqId,
        CAST(NULL AS STRING) AS reqName,
        c.idConfluence,
        c.nameConfluence,
        CAST(NULL AS STRING) AS error_text,
        CAST(NULL AS STRING) AS solution_text,
        CAST(NULL AS STRING) AS description_text,
        CAST(NULL AS STRING) AS notes_text,
        ct.embedding_confluence_data_text,
        ct.embedding_confluence_contacts_text
      ) AS base,
      LEAST(GREATEST(1.0 - b.best_distance, 0.0), 1.0) AS score
    FROM conf_best b
    JOIN `myproj.mydata.TableConfluence` c
      ON c.idConfluence = b.id
    LEFT JOIN `myproj.mydata.TableConfluenceText` ct
      ON ct.idConfluence = b.id
  )

  -- ================== Merge with flags & threshold; NO final LIMIT (per your choice) ==================
  SELECT source_table, id, name, score, base
  FROM (
    SELECT * FROM inc_joined  WHERE search_incidents
    UNION ALL
    SELECT * FROM req_joined  WHERE search_requests
    UNION ALL
    SELECT * FROM conf_joined WHERE search_confluence
  )
  WHERE threshold IS NULL OR score >= threshold
  ORDER BY score DESC
);

============ SQL ============
-- Location: us-central1
-- Params: @q ARRAY<FLOAT64>, @topK INT64, @threshold FLOAT64 (nullable)

WITH query_vec AS (SELECT @q AS emb),

-- ----------- Incidents: error / solution -----------
inc_union AS (
  SELECT 'TableIncidents' AS source_table, base.incId AS id, base.incName AS name, distance, base
  FROM VECTOR_SEARCH(
    TABLE `myproj.mydata.TableIncidents`,
    'embedding_error',
    (SELECT emb FROM query_vec), 'emb',
    top_k => @topK, distance_type => 'COSINE', options => '{}'
  )
  UNION ALL
  SELECT 'TableIncidents', base.incId, base.incName, distance, base
  FROM VECTOR_SEARCH(
    TABLE `myproj.mydata.TableIncidents`,
    'embedding_solution',
    (SELECT emb FROM query_vec), 'emb',
    top_k => @topK, distance_type => 'COSINE', options => '{}'
  )
),
inc_best AS (
  SELECT source_table, id, name, MIN(distance) AS best_distance
  FROM inc_union
  GROUP BY source_table, id, name
),
inc_joined AS (
  SELECT
    b.source_table,
    b.id,
    b.name,
    STRUCT(
      i.* EXCEPT (embedding_error, embedding_solution),
      it.embedding_error_text     AS error_text,
      it.embedding_solution_text  AS solution_text
    ) AS base,
    LEAST(GREATEST(1.0 - b.best_distance, 0.0), 1.0) AS score
  FROM inc_best b
  JOIN `myproj.mydata.TableIncidents` i
    ON i.incId = b.id
  LEFT JOIN `myproj.mydata.TableIncidentsText` it
    ON it.incId = b.id
),

-- ----------- IRequests: description / notes -----------
req_union AS (
  SELECT 'TableIRequests', base.reqId, base.reqName, distance, base
  FROM VECTOR_SEARCH(
    TABLE `myproj.mydata.TableIRequests`,
    'embedding_description',
    (SELECT emb FROM query_vec), 'emb',
    top_k => @topK, distance_type => 'COSINE', options => '{}'
  )
  UNION ALL
  SELECT 'TableIRequests', base.reqId, base.reqName, distance, base
  FROM VECTOR_SEARCH(
    TABLE `myproj.mydata.TableIRequests`,
    'embedding_notes',
    (SELECT emb FROM query_vec), 'emb',
    top_k => @topK, distance_type => 'COSINE', options => '{}'
  )
),
req_best AS (
  SELECT source_table, id, name, MIN(distance) AS best_distance
  FROM req_union
  GROUP BY source_table, id, name
),
req_joined AS (
  SELECT
    b.source_table,
    b.id,
    b.name,
    STRUCT(
      r.* EXCEPT (embedding_description, embedding_notes),
      rt.embedding_description_text AS description_text,
      rt.embedding_notes_text       AS notes_text
    ) AS base,
    LEAST(GREATEST(1.0 - b.best_distance, 0.0), 1.0) AS score
  FROM req_best b
  JOIN `myproj.mydata.TableIRequests` r
    ON r.reqId = b.id
  LEFT JOIN `myproj.mydata.TableIRequestsText` rt
    ON rt.reqId = b.id
),

-- ----------- Confluence: data / contacts -----------
conf_union AS (
  SELECT 'TableConfluence', base.idConfluence, base.nameConfluence, distance, base
  FROM VECTOR_SEARCH(
    TABLE `myproj.mydata.TableConfluence`,
    'embedding_confluence_data',
    (SELECT emb FROM query_vec), 'emb',
    top_k => @topK, distance_type => 'COSINE', options => '{}'
  )
  UNION ALL
  SELECT 'TableConfluence', base.idConfluence, base.nameConfluence, distance, base
  FROM VECTOR_SEARCH(
    TABLE `myproj.mydata.TableConfluence`,
    'embedding_confluence_contacts',
    (SELECT emb FROM query_vec), 'emb',
    top_k => @topK, distance_type => 'COSINE', options => '{}'
  )
),
conf_best AS (
  SELECT source_table, id, name, MIN(distance) AS best_distance
  FROM conf_union
  GROUP BY source_table, id, name
),
conf_joined AS (
  SELECT
    b.source_table,
    b.id,
    b.name,
    STRUCT(
      c.* EXCEPT (embedding_confluence_data, embedding_confluence_contacts),
      ct.embedding_confluence_data_text     AS confluence_data_text,
      ct.embedding_confluence_contacts_text AS confluence_contacts_text
    ) AS base,
    LEAST(GREATEST(1.0 - b.best_distance, 0.0), 1.0) AS score
  FROM conf_best b
  JOIN `myproj.mydata.TableConfluence` c
    ON c.idConfluence = b.id
  LEFT JOIN `myproj.mydata.TableConfluenceText` ct
    ON ct.idConfluence = b.id
),

-- ----------- Merge, filter, order -----------
all_scored AS (
  SELECT * FROM inc_joined
  UNION ALL SELECT * FROM req_joined
  UNION ALL SELECT * FROM conf_joined
)
SELECT
  source_table,
  id,
  name,
  base,
  TO_JSON(base) AS base_json,
  score
FROM all_scored
WHERE @threshold IS NULL OR score >= @threshold
ORDER BY score DESC
LIMIT @topK;


============ Java ============

// Request from UI
public record SemanticSearchRequest(
    String text,
    Integer topK,
    Double scoreThreshold
) {}

// Response items
public record SearchResultItem(
    String sourceTable,
    String id,
    String name,
    double score,               // 0..1
    String summary,             // ends with "(score: 0.###)"
    Map<String, Object> fields  // all non-embedding cols incl. *_text from *Text tables
) {}

public record SemanticSearchResponse(
    List<SearchResultItem> results
) {}

-----------------------------------------------------------------

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.cloud.bigquery.*;
import org.springframework.ai.embedding.Embedding;
import org.springframework.ai.embedding.EmbeddingModel;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.messages.SystemMessage;
import org.springframework.ai.chat.messages.UserMessage;
import org.springframework.ai.chat.model.ChatResponse;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.util.*;
import java.util.stream.Collectors;

@Service
public class SemanticSearchService {

    private final EmbeddingModel embeddingModel;
    private final BigQuery bigQuery;
    private final ChatClient chatClient;
    private final ObjectMapper om = new ObjectMapper();

    public SemanticSearchService(EmbeddingModel embeddingModel,
                                 BigQuery bigQuery,
                                 ChatClient chatClient) {
        this.embeddingModel = embeddingModel;
        this.bigQuery = bigQuery;
        this.chatClient = chatClient;
    }

    public SemanticSearchResponse searchAndSummarize(SemanticSearchRequest req) {
        String text = Objects.requireNonNullElse(req.text(), "").trim();
        if (!StringUtils.hasText(text)) {
            return new SemanticSearchResponse(List.of());
        }

        // 1) Embed query text and L2-normalize (your stored vectors are normalized)
        List<Double> vec = embed(text);
        List<Double> q = l2normalize(vec);

        int topK = req.topK() != null ? req.topK() : 10;
        Double threshold = req.scoreThreshold(); // nullable

        // 2) Run BigQuery
        TableResult rows = runBigQuery(q, topK, threshold);

        // 3) Build results with per-row summarization
        List<SearchResultItem> items = new ArrayList<>();
        for (FieldValueList row : rows.iterateAll()) {
            String sourceTable = row.get("source_table").getStringValue();
            String id = row.get("id").getStringValue();
            String name = row.get("name").isNull() ? "" : row.get("name").getStringValue();
            double score = row.get("score").getDoubleValue();
            Map<String, Object> fields = parseBaseJson(row.get("base_json").getStringValue());

            String summary = summarize(sourceTable, id, name, fields)
                    + String.format(" (score: %.3f)", score);

            items.add(new SearchResultItem(sourceTable, id, name, score, summary, fields));
        }
        return new SemanticSearchResponse(items);
    }

    private List<Double> embed(String text) {
        List<Embedding> res = embeddingModel.embed(List.of(text)).getResults();
        if (res.isEmpty()) throw new IllegalStateException("No embedding returned");
        return res.get(0).getOutput();
    }

    private static List<Double> l2normalize(List<Double> v) {
        double n = Math.sqrt(v.stream().mapToDouble(x -> x*x).sum());
        if (n == 0) return v;
        return v.stream().map(x -> x / n).collect(Collectors.toList());
    }

    private TableResult runBigQuery(List<Double> q, int topK, Double threshold) {
        String sql = """
            WITH query_vec AS (SELECT @q AS emb),
            inc_union AS (
              SELECT 'TableIncidents' AS source_table, base.incId AS id, base.incName AS name, distance, base
              FROM VECTOR_SEARCH(TABLE `myproj.mydata.TableIncidents`, 'embedding_error',
                                 (SELECT emb FROM query_vec), 'emb',
                                 top_k => @topK, distance_type => 'COSINE', options => '{}')
              UNION ALL
              SELECT 'TableIncidents', base.incId, base.incName, distance, base
              FROM VECTOR_SEARCH(TABLE `myproj.mydata.TableIncidents`, 'embedding_solution',
                                 (SELECT emb FROM query_vec), 'emb',
                                 top_k => @topK, distance_type => 'COSINE', options => '{}')
            ),
            inc_best AS (
              SELECT source_table, id, name, MIN(distance) AS best_distance
              FROM inc_union GROUP BY source_table, id, name
            ),
            inc_joined AS (
              SELECT b.source_table, b.id, b.name,
                     STRUCT(i.* EXCEPT (embedding_error, embedding_solution),
                            it.embedding_error_text AS error_text,
                            it.embedding_solution_text AS solution_text) AS base,
                     LEAST(GREATEST(1.0 - b.best_distance, 0.0), 1.0) AS score
              FROM inc_best b
              JOIN `myproj.mydata.TableIncidents` i ON i.incId = b.id
              LEFT JOIN `myproj.mydata.TableIncidentsText` it ON it.incId = b.id
            ),
            req_union AS (
              SELECT 'TableIRequests', base.reqId, base.reqName, distance, base
              FROM VECTOR_SEARCH(TABLE `myproj.mydata.TableIRequests`, 'embedding_description',
                                 (SELECT emb FROM query_vec), 'emb',
                                 top_k => @topK, distance_type => 'COSINE', options => '{}')
              UNION ALL
              SELECT 'TableIRequests', base.reqId, base.reqName, distance, base
              FROM VECTOR_SEARCH(TABLE `myproj.mydata.TableIRequests`, 'embedding_notes',
                                 (SELECT emb FROM query_vec), 'emb',
                                 top_k => @topK, distance_type => 'COSINE', options => '{}')
            ),
            req_best AS (
              SELECT source_table, id, name, MIN(distance) AS best_distance
              FROM req_union GROUP BY source_table, id, name
            ),
            req_joined AS (
              SELECT b.source_table, b.id, b.name,
                     STRUCT(r.* EXCEPT (embedding_description, embedding_notes),
                            rt.embedding_description_text AS description_text,
                            rt.embedding_notes_text AS notes_text) AS base,
                     LEAST(GREATEST(1.0 - b.best_distance, 0.0), 1.0) AS score
              FROM req_best b
              JOIN `myproj.mydata.TableIRequests` r ON r.reqId = b.id
              LEFT JOIN `myproj.mydata.TableIRequestsText` rt ON rt.reqId = b.id
            ),
            conf_union AS (
              SELECT 'TableConfluence', base.idConfluence, base.nameConfluence, distance, base
              FROM VECTOR_SEARCH(TABLE `myproj.mydata.TableConfluence`, 'embedding_confluence_data',
                                 (SELECT emb FROM query_vec), 'emb',
                                 top_k => @topK, distance_type => 'COSINE', options => '{}')
              UNION ALL
              SELECT 'TableConfluence', base.idConfluence, base.nameConfluence, distance, base
              FROM VECTOR_SEARCH(TABLE `myproj.mydata.TableConfluence`, 'embedding_confluence_contacts',
                                 (SELECT emb FROM query_vec), 'emb',
                                 top_k => @topK, distance_type => 'COSINE', options => '{}')
            ),
            conf_best AS (
              SELECT source_table, id, name, MIN(distance) AS best_distance
              FROM conf_union GROUP BY source_table, id, name
            ),
            conf_joined AS (
              SELECT b.source_table, b.id, b.name,
                     STRUCT(c.* EXCEPT (embedding_confluence_data, embedding_confluence_contacts),
                            ct.embedding_confluence_data_text AS confluence_data_text,
                            ct.embedding_confluence_contacts_text AS confluence_contacts_text) AS base,
                     LEAST(GREATEST(1.0 - b.best_distance, 0.0), 1.0) AS score
              FROM conf_best b
              JOIN `myproj.mydata.TableConfluence` c ON c.idConfluence = b.id
              LEFT JOIN `myproj.mydata.TableConfluenceText` ct ON ct.idConfluence = b.id
            ),
            all_scored AS (
              SELECT * FROM inc_joined
              UNION ALL SELECT * FROM req_joined
              UNION ALL SELECT * FROM conf_joined
            )
            SELECT source_table, id, name, base, TO_JSON(base) AS base_json, score
            FROM all_scored
            WHERE @threshold IS NULL OR score >= @threshold
            ORDER BY score DESC
            LIMIT @topK
            """;

        QueryJobConfiguration qjc = QueryJobConfiguration.newBuilder(sql)
            .setUseLegacySql(false)
            .setNamedParameters(Map.of(
                "q", QueryParameterValue.array(q.toArray(new Double[0]), StandardSQLTypeName.FLOAT64),
                "topK", QueryParameterValue.int64(topK),
                "threshold", threshold == null
                    ? QueryParameterValue.nullOf(StandardSQLTypeName.FLOAT64)
                    : QueryParameterValue.float64(threshold)
            ))
            .setPriority(QueryJobConfiguration.Priority.INTERACTIVE)
            .build();

        // Ensure the job runs in the same location as your dataset(s): us-central1
        JobId jobId = JobId.newBuilder().setLocation("us-central1").build();
        Job job = bigQuery.create(JobInfo.newBuilder(qjc).setJobId(jobId).build());

        try {
            job = job.waitFor();
            if (job == null) throw new RuntimeException("Job disappeared");
            if (job.getStatus().getError() != null) {
                throw new RuntimeException(job.getStatus().getError().toString());
            }
            return job.getQueryResults();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }
    }

    private Map<String, Object> parseBaseJson(String json) {
        try {
            @SuppressWarnings("unchecked")
            Map<String, Object> m = om.readValue(json, Map.class);
            // Drop embedding arrays if any slipped through (we kept them out with EXCEPT)
            m.remove("embedding_error");
            m.remove("embedding_solution");
            m.remove("embedding_description");
            m.remove("embedding_notes");
            m.remove("embedding_confluence_data");
            m.remove("embedding_confluence_contacts");
            return m;
        } catch (Exception e) {
            throw new RuntimeException("Failed to parse base_json", e);
        }
    }

    private String summarize(String sourceTable, String id, String name, Map<String, Object> fields) {
        // Prefer *_text from *Text tables; include a fallback to names
        List<String> preferred = switch (sourceTable) {
            case "TableIncidents"  -> List.of("error_text", "solution_text", "incName");
            case "TableIRequests"  -> List.of("description_text", "notes_text", "reqName");
            case "TableConfluence" -> List.of("confluence_data_text", "confluence_contacts_text", "nameConfluence");
            default -> List.of();
        };
        StringBuilder content = new StringBuilder();
        for (String k : preferred) {
            Object v = fields.get(k);
            if (v instanceof String s && !s.isBlank()) {
                content.append(k).append(": ").append(s.length() > 4000 ? s.substring(0, 4000) + "…" : s).append("\n");
            }
        }
        if (content.length() == 0) content.append(fields);

        String system = """
            You are a concise summarizer for incidents/requests/confluence notes.
            Write 1–2 sentences, factual, no speculation. Include identifiers when helpful.
            """;
        String user = "Source=%s, id=%s, name=%s\n\nContent:\n%s".formatted(sourceTable, id, name, content);

        ChatResponse r = chatClient
            .prompt(new SystemMessage(system))
            .prompt(new UserMessage(user))
            .call();

        return r.content();
    }
}

---------------------------------------------------

// Put these in SemanticSearchService
private static final int MAX_SUMMARY_CHARS = 250;

private static String normalizeWhitespace(String s) {
    if (s == null) return "";
    return s.replaceAll("\\s+", " ").trim();
}

private static String truncateToLength(String s, int maxChars) {
    if (s == null) return "";
    if (s.length() <= maxChars) return s;
    // try not to cut mid-word; fall back to hard cut
    int end = Math.max(0, Math.min(s.length(), maxChars));
    int cut = s.lastIndexOf(' ', end);
    if (cut >= 0 && cut >= end - 40) { // prefer a nearby word boundary
        end = cut;
    }
    String base = s.substring(0, end).trim();
    if (base.length() < s.length()) {
        return base + "…";
    }
    return base;
}

private String summarize(String sourceTable, String id, String name, Map<String, Object> fields) {
    List<String> keys = switch (sourceTable) {
        case "TableIncidents"  -> List.of("error_text","solution_text","incName");
        case "TableIRequests"  -> List.of("description_text","notes_text","reqName");
        case "TableConfluence" -> List.of("confluence_data_text","confluence_contacts_text","nameConfluence");
        default -> List.of();
    };
    StringBuilder sb = new StringBuilder();
    for (String k : keys) {
        Object v = fields.get(k);
        if (v instanceof String s && !s.isBlank()) {
            sb.append(k).append(": ").append(s.length() > 4000 ? s.substring(0, 4000) + "…" : s).append("\n");
        }
    }
    if (sb.length() == 0) sb.append(fields);

    String system = """
        You are a concise summarizer for incidents/requests/confluence notes.
        Return a single sentence, factual, no speculation, no bullet points or lists.
        HARD REQUIREMENT: <= 220 characters (do not exceed).
        """;
    String user = "Source=%s, id=%s, name=%s\n\nContent:\n%s"
            .formatted(sourceTable, id, name, sb);

    return chatClient
        .prompt(new SystemMessage(system))
        .prompt(new UserMessage(user))
        .call()
        .content();
}

Compute the score suffix first, then cap the content so that content + suffix ≤ 250.

for (FieldValueList r : rows.iterateAll()) {
    String sourceTable = r.get("source_table").getStringValue();
    String id   = r.get("id").getStringValue();
    String name = r.get("name").isNull() ? "" : r.get("name").getStringValue();
    double score = r.get("score").getDoubleValue();

    Map<String,Object> fields = toMap(r.get("base"), baseSubs);

    // 1) get model summary
    String raw = summarize(sourceTable, id, name, fields);

    // 2) normalize whitespace to stabilize char counts
    String normalized = normalizeWhitespace(raw);

    // 3) build score suffix and compute remaining budget
    String suffix = String.format(" (score: %.3f)", score);
    int maxContent = Math.max(0, MAX_SUMMARY_CHARS - suffix.length());

    // 4) truncate content to fit within the remaining budget, then append suffix
    String cappedContent = truncateToLength(normalized, maxContent);
    String summary = cappedContent + suffix;

    items.add(new SearchResultItem(sourceTable, id, name, score, summary, fields));
}

---------------------------------------------------

private Object toJava(FieldValue v, Field f) {
        if (v.isNull()) return null;
        switch (f.getType().getStandardType()) {
            case STRING: return v.getStringValue();
            case BOOL:   return v.getBooleanValue();
            case INT64:  return v.getLongValue();
            case FLOAT64:return v.getDoubleValue();
            case NUMERIC:return v.getNumericValue();
            case JSON:   return v.getStringValue();
            case TIMESTAMP: return v.getTimestampInstant().toString();
            case RECORD:
                Map<String, Object> m = new LinkedHashMap<>();
                FieldList subs = f.getSubFields();
                FieldValueList rec = v.getRecordValue();
                for (int i = 0; i < subs.size(); i++) {
                    m.put(subs.get(i).getName(), toJava(rec.get(i), subs.get(i)));
                }
                return m;
            case ARRAY:
                List<Object> arr = new ArrayList<>();
                Field elem = Field.of(f.getName()+"_elem", f.getType().getArrayElementType());
                for (FieldValue ev : v.getRepeatedValue()) {
                    arr.add(toJava(ev, elem));
                }
                return arr;
            default:
                return v.getStringValue();
        }
    }

---------------------------------------------------    

 // Turn a RECORD into a Map and drop all fields whose top-level name starts with "embedding_"
    private Map<String, Object> toMapDroppingEmbeddings(FieldValue base, FieldList subFields) {
        FieldValueList list = base.getRecordValue();
        Map<String, Object> out = new LinkedHashMap<>();
        for (int i = 0; i < subFields.size(); i++) {
            Field f = subFields.get(i);
            String name = f.getName();
            if (name.startsWith("embedding_")) continue; // drop embeddings
            FieldValue v = list.get(i);
            out.put(name, toJava(v, f));
        }
        return out;
    }

---------------------------------------------------    

<template>
  <v-container class="pa-0 chat-root" fluid>
    <!-- Header -->
    <v-sheet class="px-4 py-3 border-b" elevation="0">
      <div class="text-subtitle-1 font-weight-medium">Assist Chat</div>
    </v-sheet>

    <!-- Messages area -->
    <v-sheet class="messages-wrap" elevation="0">
      <div ref="scrollAreaEl" class="messages">
        <div class="d-flex flex-column" style="gap: 12px;">
          <!-- Bubbles -->
          <template v-for="m in messages" :key="m.id">
            <div
              class="d-flex"
              :class="m.sender === 'user' ? 'justify-end' : 'justify-start'"
            >
              <v-sheet
                class="pa-3 rounded-xl bubble"
                :class="m.sender === 'user' ? 'bubble-user' : 'bubble-bot'"
                elevation="1"
                max-width="80%"
              >
                <!-- If parsed server entries exist, render them all in one bubble -->
                <div v-if="m.entries && m.entries.length">
                  <div
                    v-for="(e, idx) in m.entries"
                    :key="idx"
                    class="entry-block"
                  >
                    <div class="entry-line">
                      <span class="font-weight-bold">Score: {{ e.score }}</span>
                      <span>&nbsp;</span>

                      <!-- Render processed $$... [id] $$ segments -->
                      <template v-for="(seg, k) in e.textSegments" :key="k">
                        <span v-if="seg.type === 'text'">{{ seg.text }}</span>
                        <v-btn
                          v-else
                          variant="text"
                          density="compact"
                          class="px-0 link-underline link-bold"
                          @click="onLinkClick((seg as LinkSegment).href)"
                        >
                          {{ (seg as LinkSegment).text }}
                        </v-btn>
                      </template>
                    </div>

                    <!-- Optional contacts table (confluence only) -->
                    <div v-if="e.table" class="mt-2">
                      <v-table density="comfortable">
                        <thead>
                          <tr>
                            <th v-for="(h, i) in e.table.headers" :key="i" class="text-no-wrap">
                              {{ h }}
                            </th>
                          </tr>
                        </thead>
                        <tbody>
                          <tr v-for="(row, rIdx) in e.table.rows" :key="rIdx">
                            <td v-for="(cell, cIdx) in row" :key="cIdx">
                              {{ cell }}
                            </td>
                          </tr>
                        </tbody>
                      </v-table>
                    </div>

                    <v-divider v-if="idx < m.entries.length - 1" class="my-3" />
                  </div>
                </div>

                <!-- Fallback: non-JSON text/anchor rendering -->
                <template v-else>
                  <template v-for="(seg, idx) in m.segments" :key="idx">
                    <span v-if="seg.type === 'text'">{{ seg.text }}</span>
                    <v-btn
                      v-else
                      variant="text"
                      density="compact"
                      class="px-0 link-underline"
                      @click="onLinkClick((seg as LinkSegment).href)"
                    >
                      {{ (seg as LinkSegment).text }}
                    </v-btn>
                  </template>
                </template>

                <!-- Timestamp -->
                <div class="timestamp">
                  {{ formatTimestamp(m.timestamp) }}
                </div>
              </v-sheet>
            </div>
          </template>

          <!-- Busy indicator (AI-style) -->
          <div v-if="busy" class="d-flex justify-start">
            <v-sheet class="pa-3 rounded-xl bubble bubble-bot" elevation="1" max-width="60%">
              <div class="d-flex align-center" style="gap: 10px;">
                <span class="vertex-anim" aria-hidden="true">
                  <v-icon size="22" class="vertex-sparkle">mdi-creation</v-icon>
                </span>
                <span>{{ busyMessage }}</span>
              </div>
            </v-sheet>
          </div>

          <!-- Bottom sentinel to ensure reliable scrolling -->
          <div ref="bottomSentinel" style="height: 1px;"></div>
        </div>
      </div>
    </v-sheet>

    <!-- Sticky input area -->
    <div class="input-sticky">
      <v-divider />
      <v-progress-linear v-if="busy" indeterminate height="3" />
      <v-sheet class="px-3 py-2" elevation="0">
        <v-text-field
          ref="inputRef"
          v-model="draft"
          variant="outlined"
          density="comfortable"
          :disabled="busy"
          :placeholder="busy ? busyMessage : 'Type your message…'"
          hide-details
          clearable
          @keydown.enter="trySend"
          class="ma-0"
        >
          <template #append-inner>
            <v-btn
              icon
              :disabled="busy || !canSend"
              @click="trySend"
              :aria-label="'Send message'"
            >
              <v-icon>mdi-send</v-icon>
            </v-btn>
          </template>
        </v-text-field>
      </v-sheet>
    </div>
  </v-container>
</template>

<script lang="ts">
import { defineComponent, ref, computed, nextTick, watch, onMounted, onBeforeUnmount } from 'vue';
import { sendQuery, processChatAction } from './AssistChat';

type Sender = 'user' | 'bot';
type TextSegment = { type: 'text'; text: string };
type LinkSegment = { type: 'link'; text: string; href: string };
type Segment = TextSegment | LinkSegment;

interface TablePayload {
  headers: string[];
  rows: Array<Array<string | number | null>>;
}

interface RichMessageEntry {
  score: string;
  type: string;
  textSegments: Segment[];
  table?: TablePayload | null;
}

interface ChatMessage {
  id: string;
  sender: Sender;
  raw: string;
  segments: Segment[];     // fallback/plain path
  timestamp: Date;
  entries?: RichMessageEntry[]; // server "messages" array rendered in this bubble
}

export default defineComponent({
  name: 'AssistChat',
  setup() {
    // --- State ---
    const messages = ref<ChatMessage[]>([]);
    const draft = ref('');
    const busy = ref(false);

    // Busy message rotation (one pass, stop at last)
    const busyMessages = [
      'Thinking…',
      'Connecting to data sources…',
      'Retrieving data…',
      'Preparing data…', // final; freeze here
    ] as const;
    const busyMessage = ref(busyMessages[0]);
    let busyTimer: ReturnType<typeof setInterval> | null = null;
    let busyIdx = 0;

    // Refs for scrolling & focus
    const scrollAreaEl = ref<HTMLElement | null>(null);
    const bottomSentinel = ref<HTMLElement | null>(null);
    const inputRef = ref<any | null>(null);

    const canSend = computed(() => draft.value.trim().length > 0 && !busy.value);

    // --- Formatting ---
    function formatTimestamp(d: Date): string {
      return new Intl.DateTimeFormat('en-US', {
        month: '2-digit',
        day: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        hour12: false,
      }).format(d);
    }

    // --- Parsing helpers ---
    // Fallback: parse <a href="..">text</a>
    function parseAnchorSegments(htmlish: string): Segment[] {
      const container = document.createElement('div');
      container.innerHTML = htmlish;
      const result: Segment[] = [];

      function walk(node: ChildNode) {
        if (node.nodeType === Node.TEXT_NODE) {
          const text = node.textContent ?? '';
          if (text) result.push({ type: 'text', text });
          return;
        }
        if (node.nodeType === Node.ELEMENT_NODE) {
          const el = node as HTMLElement;
          if (el.tagName.toLowerCase() === 'a') {
            const href = el.getAttribute('href') || '';
            const text = el.textContent?.trim() || href || 'link';
            result.push({ type: 'link', text, href });
            return;
          }
          Array.from(node.childNodes).forEach(walk);
        }
      }
      Array.from(container.childNodes).forEach(walk);
      return result.length ? result : [{ type: 'text', text: htmlish }];
    }

    // Convert "… $$ABC[myId]$$ …" to segments; link text is inside $$, href is bracket id
    function parseDollarLinkSegments(text: string): Segment[] {
      const segs: Segment[] = [];
      const regex = /\$\$(.+?)\$\$/g; // non-greedy between $$
      let lastIndex = 0;
      let match: RegExpExecArray | null;

      while ((match = regex.exec(text)) !== null) {
        const start = match.index;
        const end = regex.lastIndex;
        const inside = match[1]; // e.g., ABC[myId]

        if (start > lastIndex) segs.push({ type: 'text', text: text.slice(lastIndex, start) });

        const idMatch = inside.match(/\[([^\]]+)\]/);
        const id = idMatch ? idMatch[1] : inside; // href passed to onLinkClick
        const display = inside;                   // show full inside content, as requested

        segs.push({ type: 'link', text: display, href: id });
        lastIndex = end;
      }
      if (lastIndex < text.length) segs.push({ type: 'text', text: text.slice(lastIndex) });
      return segs.length ? segs : [{ type: 'text', text }];
    }

    // Build contacts table from first entry headers
    function buildContactsTable(contacts: any[]): TablePayload | null {
      if (!Array.isArray(contacts) || contacts.length === 0) return null;
      const headerMap = contacts[0];
      if (!headerMap || typeof headerMap !== 'object') return null;

      const headerKeys = Object.keys(headerMap).sort((a, b) => {
        const na = Number(String(a).replace(/[^\d]/g, '') || '0');
        const nb = Number(String(b).replace(/[^\d]/g, '') || '0');
        return na - nb;
      });
      const headers = headerKeys.map((k) => String(headerMap[k] ?? '').trim());

      const rows: Array<Array<string | number | null>> = [];
      for (let i = 1; i < contacts.length; i++) {
        const rowObj = contacts[i] ?? {};
        const row = headers.map((h) => {
          const v = rowObj[h];
          return v === undefined ? null : (typeof v === 'object' ? JSON.stringify(v) : v);
        });
        rows.push(row);
      }
      return { headers, rows };
    }

    // Parse new server schema: { messages: [ { score, type, contacts, text }, ... ] }
    function tryParseServerMessages(raw: string) {
      let obj: any;
      try {
        obj = JSON.parse(raw);
      } catch {
        return null; // not JSON
      }
      if (!obj || typeof obj !== 'object' || !Array.isArray(obj.messages)) return null;

      const result: RichMessageEntry[] = [];
      for (const item of obj.messages) {
        const score = String(item?.score ?? '');
        const type = String(item?.type ?? '');
        const text = String(item?.text ?? '');
        const textSegments = parseDollarLinkSegments(text);

        let table: TablePayload | null = null;
        if (type === 'confluence' && Array.isArray(item?.contacts) && item.contacts.length) {
          table = buildContactsTable(item.contacts);
        }

        result.push({ score, type, textSegments, table });
      }
      return result;
    }

    // --- Scroll/focus helpers ---
    async function scrollToBottom(smooth = false) {
      await nextTick();
      await new Promise(requestAnimationFrame);

      const sentinel = bottomSentinel.value;
      if (sentinel?.scrollIntoView) {
        sentinel.scrollIntoView({ behavior: smooth ? 'smooth' : 'auto', block: 'end' });
        return;
      }
      const el = scrollAreaEl.value;
      if (!el) return;
      if (typeof (el as any).scrollTo === 'function') {
        (el as any).scrollTo({ top: el.scrollHeight, behavior: smooth ? 'smooth' : 'auto' });
      } else {
        el.scrollTop = el.scrollHeight;
      }
    }

    async function focusInput() {
      await nextTick();
      await new Promise(requestAnimationFrame);
      if (inputRef.value?.focus) {
        inputRef.value.focus();
        return;
      }
      const el: HTMLInputElement | null = inputRef.value?.$el?.querySelector?.('input') ?? null;
      el?.focus();
    }

    function appendMessage(sender: Sender, raw: string) {
      let entries: RichMessageEntry[] | null = null;
      if (sender === 'bot') entries = tryParseServerMessages(raw);

      messages.value.push({
        id: Math.random().toString(36).slice(2, 9),
        sender,
        raw,
        segments: entries ? [] : parseAnchorSegments(raw),
        timestamp: new Date(),
        entries: entries ?? undefined,
      });

      scrollToBottom(sender === 'user');
    }

    function updateResult(response: string) {
      appendMessage('bot', response);
      scrollToBottom(true);
      focusInput();
    }

    async function trySend() {
      if (!canSend.value) return;

      const text = draft.value.trim();
      draft.value = '';
      appendMessage('user', text);

      // Start busy & rotate messages once
      busy.value = true;

      // reveal busy bubble
      await scrollToBottom(false);

      try {
        const response = await sendQuery(text);
        updateResult(response);
      } catch (err) {
        updateResult('Sorry, something went wrong.');
        // eslint-disable-next-line no-console
        console.error(err);
      } finally {
        busy.value = false;
        focusInput();
      }
    }

    function onLinkClick(href: string) {
      processChatAction(href); // calls existing function from AssistChat.ts
      focusInput();
    }

    // Busy message rotation controller
    function stopBusyTimer() {
      if (busyTimer) {
        clearInterval(busyTimer);
        busyTimer = null;
      }
    }
    watch(busy, (isBusy) => {
      stopBusyTimer();
      if (isBusy) {
        busyIdx = 0;
        busyMessage.value = busyMessages[busyIdx];
        busyTimer = setInterval(() => {
          if (busyIdx < busyMessages.length - 1) {
            busyIdx += 1;
            busyMessage.value = busyMessages[busyIdx];
            if (busyIdx === busyMessages.length - 1) stopBusyTimer(); // freeze at last
          }
        }, 2000);
      }
      // when not busy, placeholder falls back via template ternary
    }, { immediate: true });

    // Safety nets
    watch(() => messages.value.length, () => scrollToBottom(false));
    onMounted(() => {
      focusInput();
      scrollToBottom(false);
    });
    onBeforeUnmount(() => stopBusyTimer());

    return {
      // state
      messages,
      draft,
      busy,
      busyMessage,
      // refs
      scrollAreaEl,
      bottomSentinel,
      inputRef,
      // computed & methods
      canSend,
      trySend,
      onLinkClick,
      formatTimestamp,
    };
  },
});
</script>

<style scoped>
/* Layout */
.chat-root {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  background: #ffffff;
}
.border-b {
  border-bottom: 1px solid rgba(0, 0, 0, 0.08);
}
.messages-wrap {
  flex: 1 1 0;
  min-height: 0;
  background: transparent;
  padding: 0;
}
.messages {
  height: 100%;
  overflow: auto;
  min-height: 0;
  padding: 16px 12px;
}
.input-sticky {
  position: sticky;
  bottom: 0;
  background: #ffffff;
  z-index: 2;
  padding-bottom: env(safe-area-inset-bottom);
}

/* Bubbles */
.bubble {
  white-space: pre-wrap;
  word-break: break-word;
}
.bubble-user {
  background-color: silver !important;
  color: rgba(0, 0, 0, 0.87);
}
.bubble-bot {
  background-color: #A5D6A7 !important;
  color: rgba(0, 0, 0, 0.87);
}

/* Links rendered from $$... [id] $$ */
.link-underline { text-decoration: underline; }
.link-bold { font-weight: 600; }

/* Timestamp */
.timestamp {
  margin-top: 6px;
  font-size: 0.75rem;
  color: rgba(0, 0, 0, 0.54);
  text-align: right;
}

/* Entry spacing inside one bubble */
.entry-block + .entry-block { margin-top: 10px; }
.entry-line { line-height: 1.5; }

/* Vertex-style animated busy icon */
.vertex-anim {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  animation: vertex-spin-pulse 12s linear infinite;
}
.vertex-sparkle {
  background: conic-gradient(
    from 0deg,
    #7b61ff 0%,
    #4f8cff 20%,
    #00bcd4 40%,
    #00e5a8 60%,
    #ffd54f 80%,
    #ff6e6e 100%
  );
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: vertex-hue 4.5s linear infinite;
}

/* Hue shimmer */
@keyframes vertex-hue {
  0%   { filter: none; }
  50%  { filter: hue-rotate(40deg) saturate(1.15); }
  100% { filter: none; }
}
/* Slow rotate + gentle pulse (applied on wrapper to avoid transform conflicts) */
@keyframes vertex-spin-pulse {
  0%   { transform: rotate(0deg) scale(1); }
  50%  { transform: rotate(180deg) scale(1.12); }
  100% { transform: rotate(360deg) scale(1); }
}
</style>

---------------------------------------------------    

export async function sendQuery(userText: string): Promise<string> {
  // Simulate latency
  await new Promise((r) => setTimeout(r, 900));

  const lc = userText.trim().toLowerCase();

  if (lc === 'table') {
    // Includes confluence items (with contacts table) and $$... [id] $$ links
    return JSON.stringify({
      messages: [
        {
          score: "1.00",
          type: "confluence",
          contacts: [
            { header1: "level", header2: "contact", header3: "email" },
            { level: 1, contact: "Alice", email: "alice@example.com" },
            { level: 2, contact: "Bob",   email: "bob@example.com"   },
            { level: 3, contact: "Chad",  email: "chad@example.com"  }
          ],
          text:
            "Primary runbook at $$RB-1234[confPage]$$, follow up in $$INC-9001[incident]$$, and cross-ref $$REQ-42[request]$$."
        },
        {
          score: "0.82",
          type: "inc",
          contacts: [],
          text:
            "Related incident: $$INC-2024-0801[incident]$$. Summary attached in $$DOC-777[docId]$$."
        },
        {
          score: "0.68",
          type: "confluence",
          contacts: [
            { header1: "level", header2: "contact" },
            { level: 1, contact: "Ops-OnCall" },
            { level: 2, contact: "SRE-Lead" }
          ],
          text:
            "Escalation ladder defined in $$CONF-ALPHA[confPage]$$. Use $$HOT-KEYS[shortcuts]$$ during triage."
        }
      ]
    });
  }

  if (lc === 'hello') {
    // No confluence type here → no tables should render
    return JSON.stringify({
      messages: [
        {
          score: "0.95",
          type: "requests",
          contacts: [],
          text:
            "Hi there! Check $$REQ-1001[request]$$ and $$REQ-1002[request]$$ for recent asks."
        },
        {
          score: "0.72",
          type: "inc",
          contacts: [],
          text:
            "Previous outage summary: $$INC-5555[incident]$$; RCA draft $$RCA-321[draft]$$."
        }
      ]
    });
  }

  if (lc === 'mix') {
    // Mixed response: confluence with contacts, confluence without contacts, and non-confluence
    return JSON.stringify({
      messages: [
        {
          score: "1.00",
          type: "confluence",
          contacts: [
            { header1: "level", header2: "contact" },
            { level: 1, contact: "Tier-1" },
            { level: 2, contact: "Tier-2" },
            { level: 3, contact: "Tier-3" }
          ],
          text:
            "See $$CONF-ROOT[confPage]$$ and jump to $$JIRA-1234[ticket]$$ for open work."
        },
        {
          score: "0.80",
          type: "confluence",
          contacts: [], // intentionally empty → no table should render
          text:
            "General notes kept at $$DOC-ABC123[docId]$$. Shortcut: $$KB-42[kb]$$."
        },
        {
          score: "0.64",
          type: "inc",
          contacts: [],
          text:
            "Recent alerts related: $$ALERT-77[alert]$$ and $$ALERT-78[alert]$$."
        }
      ]
    });
  }

  if (lc === 'raw') {
    // Fallback / legacy: not JSON (tests your non-JSON anchor parsing path)
    return 'Legacy path: <a href="https://vuetifyjs.com">Vuetify Docs</a>';
  }

  // Default echo → simple message array with one non-confluence item
  return JSON.stringify({
    messages: [
      {
        score: "0.50",
        type: "requests",
        contacts: [],
        text: `You said "${userText}". Try "table", "hello", "mix", or "raw". See $$HELP-001[help]$$.`
      }
    ]
  });
}


--------------------------------------------------------------------------------------

<template>
  <v-container class="pa-0 chat-root" fluid>
    <!-- Header -->
    <v-sheet class="px-4 py-3 border-b" elevation="0">
      <div class="text-subtitle-1 font-weight-medium">AI Chat</div>
    </v-sheet>

    <!-- Messages area -->
    <v-sheet class="messages-wrap" elevation="0">
      <div ref="scrollAreaEl" class="messages">
        <div class="d-flex flex-column" style="gap: 12px;">
          <!-- Bubbles -->
          <template v-for="m in messages" :key="m.id">
            <div
              class="d-flex"
              :class="m.sender === 'user' ? 'justify-end' : 'justify-start'"
            >
              <!-- anchor target for user bubbles -->
              <div v-if="m.sender === 'user'" :id="m.anchorId" class="bubble-anchor" />

              <v-sheet
                class="pa-3 rounded-xl bubble"
                :class="m.sender === 'user' ? 'bubble-user' : 'bubble-bot'"
                elevation="1"
                max-width="80%"
              >
                <!-- If parsed server entries exist, render them all in one bubble -->
                <div v-if="m.entries && m.entries.length">
                  <div v-for="(e, idx) in m.entries" :key="idx" class="entry-block">
                    <div class="entry-line">
                      <span class="font-weight-bold">Score: {{ e.score }}</span>
                      <span>&nbsp;</span>

                      <!-- Render processed $$... [id] $$ segments -->
                      <template v-for="(seg, k) in e.textSegments" :key="k">
                        <span v-if="seg.type === 'text'">{{ seg.text }}</span>
                        <v-btn
                          v-else
                          variant="text"
                          density="compact"
                          class="px-0 link-underline link-bold"
                          @click="onLinkClick((seg as LinkSegment).href)"
                        >
                          {{ (seg as LinkSegment).text }}
                        </v-btn>
                      </template>
                    </div>

                    <!-- Optional contacts table (confluence only) -->
                    <div v-if="e.table" class="mt-2">
                      <v-table density="comfortable">
                        <thead>
                          <tr>
                            <th v-for="(h, i) in e.table.headers" :key="i" class="text-no-wrap">
                              {{ h }}
                            </th>
                          </tr>
                        </thead>
                        <tbody>
                          <tr v-for="(row, rIdx) in e.table.rows" :key="rIdx">
                            <td v-for="(cell, cIdx) in row" :key="cIdx">
                              {{ cell }}
                            </td>
                          </tr>
                        </tbody>
                      </v-table>
                    </div>

                    <v-divider v-if="idx < m.entries.length - 1" class="my-3" />
                  </div>
                </div>

                <!-- Fallback: non-JSON text/anchor rendering -->
                <template v-else>
                  <template v-for="(seg, idx) in m.segments" :key="idx">
                    <span v-if="seg.type === 'text'">{{ seg.text }}</span>
                    <v-btn
                      v-else
                      variant="text"
                      density="compact"
                      class="px-0 link-underline"
                      @click="onLinkClick((seg as LinkSegment).href)"
                    >
                      {{ (seg as LinkSegment).text }}
                    </v-btn>
                  </template>
                </template>

                <!-- Timestamp -->
                <div class="timestamp">
                  {{ formatTimestamp(m.timestamp) }}
                </div>
              </v-sheet>
            </div>
          </template>

          <!-- Busy indicator (AI-style) -->
          <div v-if="busy" class="d-flex justify-start">
            <v-sheet class="pa-3 rounded-xl bubble bubble-bot" elevation="1" max-width="60%">
              <div class="d-flex align-center" style="gap: 10px;">
                <span class="vertex-anim" aria-hidden="true">
                  <v-icon size="22" class="vertex-sparkle">mdi-creation</v-icon>
                </span>
                <span>{{ busyMessage }}</span>
              </div>
            </v-sheet>
          </div>

          <!-- Bottom sentinel to ensure reliable scrolling -->
          <div ref="bottomSentinel" style="height: 1px;"></div>
        </div>
      </div>
    </v-sheet>

    <!-- Sticky input area -->
    <div class="input-sticky">
      <v-divider />
      <v-progress-linear v-if="busy" indeterminate height="3" />
      <v-sheet class="px-3 py-2" elevation="0">
        <v-text-field
          ref="inputRef"
          v-model="draft"
          variant="outlined"
          density="comfortable"
          :disabled="busy"
          :placeholder="busy ? busyMessage : 'Type your message…'"
          hide-details
          clearable
          @keydown.enter="trySend"
          class="ma-0"
        >
          <template #append-inner>
            <v-btn
              icon
              :disabled="busy || !canSend"
              @click="trySend"
              :aria-label="'Send message'"
            >
              <v-icon>mdi-send</v-icon>
            </v-btn>
          </template>
        </v-text-field>
      </v-sheet>
    </div>
  </v-container>
</template>

<script lang="ts">
import {
  defineComponent, ref, computed, nextTick, watch,
  onMounted, onBeforeUnmount, reactive, toRaw, getCurrentInstance, expose
} from 'vue';
import { sendQuery, processChatAction } from './AssistChat';

type Sender = 'user' | 'bot';
type TextSegment = { type: 'text'; text: string };
type LinkSegment = { type: 'link'; text: string; href: string };
type Segment = TextSegment | LinkSegment;

interface TablePayload {
  headers: string[];
  rows: Array<Array<string | number | null>>;
}
interface RichMessageEntry {
  score: string;
  type: string;
  textSegments: Segment[];
  table?: TablePayload | null;
}
interface ChatMessage {
  id: string;
  sender: Sender;
  raw: string;
  segments: Segment[];     // fallback/plain path
  timestamp: Date;
  entries?: RichMessageEntry[]; // server "messages" array rendered in this bubble
  anchorId?: string;            // only for user bubbles
}

export default defineComponent({
  name: 'AssistChat',
  emits: ['anchors-updated'], // notify parent/sidebar
  setup(_, { emit }) {
    // --- State ---
    const messages = ref<ChatMessage[]>([]);
    const draft = ref('');
    const busy = ref(false);

    // Busy message rotation (one pass, stop at last)
    const busyMessages = [
      'Thinking…',
      'Connecting to data sources…',
      'Retrieving data…',
      'Preparing data…', // final; freeze here
    ] as const;
    const busyMessage = ref(busyMessages[0]);
    let busyTimer: ReturnType<typeof setInterval> | null = null;
    let busyIdx = 0;

    // Refs for scrolling & focus
    const scrollAreaEl = ref<HTMLElement | null>(null);
    const bottomSentinel = ref<HTMLElement | null>(null);
    const inputRef = ref<any | null>(null);

    // --- Anchor map (key -> anchorId) ---
    // Keys: user text, bot hyperlink href; Value: anchor id of latest user bubble
    const anchorMap = reactive(new Map<string, string>());
    let lastUserAnchorId: string | null = null;

    const canSend = computed(() => draft.value.trim().length > 0 && !busy.value);

    // --- Formatting ---
    function formatTimestamp(d: Date): string {
      return new Intl.DateTimeFormat('en-US', {
        month: '2-digit',
        day: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        hour12: false,
      }).format(d);
    }

    // --- Parsing helpers ---
    function parseAnchorSegments(htmlish: string): Segment[] {
      const container = document.createElement('div');
      container.innerHTML = htmlish;
      const result: Segment[] = [];
      function walk(node: ChildNode) {
        if (node.nodeType === Node.TEXT_NODE) {
          const text = node.textContent ?? '';
          if (text) result.push({ type: 'text', text });
          return;
        }
        if (node.nodeType === Node.ELEMENT_NODE) {
          const el = node as HTMLElement;
          if (el.tagName.toLowerCase() === 'a') {
            const href = el.getAttribute('href') || '';
            const text = el.textContent?.trim() || href || 'link';
            result.push({ type: 'link', text, href });
            return;
          }
          Array.from(node.childNodes).forEach(walk);
        }
      }
      Array.from(container.childNodes).forEach(walk);
      return result.length ? result : [{ type: 'text', text: htmlish }];
    }

    // Convert $$... [id] $$ into segments (link text is full inside, href is [id])
    function parseDollarLinkSegments(text: string): Segment[] {
      const segs: Segment[] = [];
      const regex = /\$\$(.+?)\$\$/g;
      let lastIndex = 0;
      let match: RegExpExecArray | null;
      while ((match = regex.exec(text)) !== null) {
        const start = match.index;
        const end = regex.lastIndex;
        const inside = match[1];
        if (start > lastIndex) segs.push({ type: 'text', text: text.slice(lastIndex, start) });
        const idMatch = inside.match(/\[([^\]]+)\]/);
        const id = idMatch ? idMatch[1] : inside;
        segs.push({ type: 'link', text: inside, href: id });
        lastIndex = end;
      }
      if (lastIndex < text.length) segs.push({ type: 'text', text: text.slice(lastIndex) });
      return segs.length ? segs : [{ type: 'text', text }];
    }

    function buildContactsTable(contacts: any[]): TablePayload | null {
      if (!Array.isArray(contacts) || contacts.length === 0) return null;
      const headerMap = contacts[0];
      if (!headerMap || typeof headerMap !== 'object') return null;

      const headerKeys = Object.keys(headerMap).sort((a, b) => {
        const na = Number(String(a).replace(/[^\d]/g, '') || '0');
        const nb = Number(String(b).replace(/[^\d]/g, '') || '0');
        return na - nb;
      });
      const headers = headerKeys.map((k) => String(headerMap[k] ?? '').trim());

      const rows: Array<Array<string | number | null>> = [];
      for (let i = 1; i < contacts.length; i++) {
        const rowObj = contacts[i] ?? {};
        const row = headers.map((h) => {
          const v = rowObj[h];
          return v === undefined ? null : (typeof v === 'object' ? JSON.stringify(v) : v);
        });
        rows.push(row);
      }
      return { headers, rows };
    }

    function tryParseServerMessages(raw: string) {
      let obj: any;
      try { obj = JSON.parse(raw); } catch { return null; }
      if (!obj || typeof obj !== 'object' || !Array.isArray(obj.messages)) return null;

      const result: RichMessageEntry[] = [];
      for (const item of obj.messages) {
        const score = String(item?.score ?? '');
        const type = String(item?.type ?? '');
        const text = String(item?.text ?? '');
        const textSegments = parseDollarLinkSegments(text);

        let table: TablePayload | null = null;
        if (type === 'confluence' && Array.isArray(item?.contacts) && item.contacts.length) {
          table = buildContactsTable(item.contacts);
        }
        result.push({ score, type, textSegments, table });
      }
      return result;
    }

    // --- Scroll/focus helpers ---
    async function scrollToBottom(smooth = false) {
      await nextTick();
      await new Promise(requestAnimationFrame);
      const sentinel = bottomSentinel.value;
      if (sentinel?.scrollIntoView) {
        sentinel.scrollIntoView({ behavior: smooth ? 'smooth' : 'auto', block: 'end' });
        return;
      }
      const el = scrollAreaEl.value;
      if (!el) return;
      if (typeof (el as any).scrollTo === 'function') {
        (el as any).scrollTo({ top: el.scrollHeight, behavior: smooth ? 'smooth' : 'auto' });
      } else {
        el.scrollTop = el.scrollHeight;
      }
    }

    async function focusInput() {
      await nextTick(); await new Promise(requestAnimationFrame);
      if (inputRef.value?.focus) { inputRef.value.focus(); return; }
      const el: HTMLInputElement | null = inputRef.value?.$el?.querySelector?.('input') ?? null;
      el?.focus();
    }

    // --- Anchor helpers ---
    function emitAnchorsUpdated() {
      // Emit a plain array so parent can render without worrying about Map
      const entries = Array.from(anchorMap.entries()).map(([key, id]) => ({ key, id }));
      emit('anchors-updated', entries);
    }

    function registerAnchorKey(key: string, anchorId: string) {
      if (!key || !anchorId) return;
      anchorMap.set(key, anchorId);
      emitAnchorsUpdated();
    }

    function getScrollContainer(): HTMLElement | null {
      return scrollAreaEl.value;
    }

    async function scrollToAnchorId(id: string, smooth = true) {
      await nextTick(); await new Promise(requestAnimationFrame);
      const container = getScrollContainer();
      if (!container) return;
      const target = document.getElementById(id);
      if (!target) return;

      // Scroll within container (not whole page)
      const containerRect = container.getBoundingClientRect();
      const targetRect = target.getBoundingClientRect();
      const offset = targetRect.top - containerRect.top + container.scrollTop - 8; // small padding
      if (typeof (container as any).scrollTo === 'function') {
        (container as any).scrollTo({ top: offset, behavior: smooth ? 'smooth' : 'auto' });
      } else {
        container.scrollTop = offset;
      }
    }

    async function scrollToAnchorByKey(key: string) {
      const id = anchorMap.get(key);
      if (id) {
        await scrollToAnchorId(id, true);
      }
    }

    // --- Messaging core ---
    function uid(): string { return Math.random().toString(36).slice(2, 9); }

    function appendMessage(sender: Sender, raw: string) {
      let entries: RichMessageEntry[] | null = null;
      if (sender === 'bot') entries = tryParseServerMessages(raw);

      const msg: ChatMessage = {
        id: uid(),
        sender,
        raw,
        segments: entries ? [] : parseAnchorSegments(raw),
        timestamp: new Date(),
        entries: entries ?? undefined,
      };

      // Create an anchor for every user message
      if (sender === 'user') {
        msg.anchorId = `anchor-${msg.id}`;
      }

      messages.value.push(msg);

      // If user message: remember last anchor and record key -> anchorId for user text
      if (sender === 'user' && msg.anchorId) {
        lastUserAnchorId = msg.anchorId;
        const textKey = raw.trim();
        if (textKey) registerAnchorKey(textKey, msg.anchorId);
      }

      scrollToBottom(sender === 'user');
    }

    function updateResult(response: string) {
      appendMessage('bot', response);
      scrollToBottom(true);
      focusInput();
    }

    async function trySend() {
      if (!canSend.value) return;

      const text = draft.value.trim();
      draft.value = '';
      appendMessage('user', text);

      busy.value = true;
      await scrollToBottom(false);

      try {
        const response = await sendQuery(text);
        updateResult(response);
      } catch (err) {
        updateResult('Sorry, something went wrong.');
        // eslint-disable-next-line no-console
        console.error(err);
      } finally {
        busy.value = false;
        focusInput();
      }
    }

    function onLinkClick(href: string) {
      // Store href -> last user anchor id
      if (href && lastUserAnchorId) {
        registerAnchorKey(href, lastUserAnchorId);
      }
      processChatAction(href);
      focusInput();
    }

    // Busy message rotation controller
    function stopBusyTimer() {
      if (busyTimer) { clearInterval(busyTimer); busyTimer = null; }
    }
    watch(busy, (isBusy) => {
      stopBusyTimer();
      if (isBusy) {
        busyIdx = 0;
        busyMessage.value = busyMessages[busyIdx];
        busyTimer = setInterval(() => {
          if (busyIdx < busyMessages.length - 1) {
            busyIdx += 1;
            busyMessage.value = busyMessages[busyIdx];
            if (busyIdx === busyMessages.length - 1) stopBusyTimer(); // freeze at last
          }
        }, 2000);
      }
    }, { immediate: true });

    // Safety nets
    watch(() => messages.value.length, () => scrollToBottom(false));
    onMounted(() => { focusInput(); scrollToBottom(false); });
    onBeforeUnmount(() => stopBusyTimer());

    // Expose scroll methods so the parent/sidebar can call them via ref
    expose({
      scrollToAnchorId,
      scrollToAnchorByKey,
      getAnchorEntries: () => Array.from(anchorMap.entries()).map(([key, id]) => ({ key, id })),
    });

    return {
      // state
      messages, draft, busy, busyMessage,
      // refs
      scrollAreaEl, bottomSentinel, inputRef,
      // computed & methods
      canSend, trySend, onLinkClick, formatTimestamp,
      // for local/manual testing (optional)
      scrollToAnchorId, scrollToAnchorByKey,
    };
  },
});
</script>

<style scoped>
/* Layout */
.chat-root { display: flex; flex-direction: column; height: 100%; width: 100%; background: #ffffff; }
.border-b { border-bottom: 1px solid rgba(0, 0, 0, 0.08); }
.messages-wrap { flex: 1 1 0; min-height: 0; background: transparent; padding: 0; }
.messages { height: 100%; overflow: auto; min-height: 0; padding: 16px 12px; }
.input-sticky { position: sticky; bottom: 0; background: #ffffff; z-index: 2; padding-bottom: env(safe-area-inset-bottom); }

/* Anchor target (small invisible spacer so scroll lands nicely) */
.bubble-anchor { height: 1px; margin-top: -4px; }

/* Bubbles */
.bubble { white-space: pre-wrap; word-break: break-word; }
.bubble-user { background-color: silver !important; color: rgba(0, 0, 0, 0.87); }
.bubble-bot { background-color: #A5D6A7 !important; color: rgba(0, 0, 0, 0.87); }

/* Links rendered from $$... [id] $$ */
.link-underline { text-decoration: underline; }
.link-bold { font-weight: 600; }

/* Timestamp */
.timestamp { margin-top: 6px; font-size: 0.75rem; color: rgba(0, 0, 0, 0.54); text-align: right; }

/* Entry spacing inside one bubble */
.entry-block + .entry-block { margin-top: 10px; }
.entry-line { line-height: 1.5; }

/* Vertex-style animated busy icon */
.vertex-anim { display: inline-flex; align-items: center; justify-content: center; animation: vertex-spin-pulse 12s linear infinite; }
.vertex-sparkle {
  background: conic-gradient(
    from 0deg,
    #7b61ff 0%,
    #4f8cff 20%,
    #00bcd4 40%,
    #00e5a8 60%,
    #ffd54f 80%,
    #ff6e6e 100%
  );
  -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent;
  animation: vertex-hue 4.5s linear infinite;
}
/* Hue shimmer */
@keyframes vertex-hue { 0% { filter:none; } 50% { filter:hue-rotate(40deg) saturate(1.15); } 100% { filter:none; } }
/* Slow rotate + gentle pulse */
@keyframes vertex-spin-pulse { 0% { transform: rotate(0deg) scale(1); } 50% { transform: rotate(180deg) scale(1.12); } 100% { transform: rotate(360deg) scale(1); } }
</style>

-----------------------------------------------------------------------------

<template>
  <v-row class="h-100">
    <v-col cols="3">
      <!-- Your sidebar -->
      <v-list dense>
        <v-list-item
          v-for="(e, i) in anchorEntries"
          :key="i"
          @click="chatRef?.scrollToAnchorByKey(e.key)"
        >
          <v-list-item-title>{{ e.key }}</v-list-item-title>
        </v-list-item>
      </v-list>
    </v-col>

    <v-col cols="9" class="h-100">
      <AssistChat
        ref="chatRef"
        @anchors-updated="anchorEntries = $event"
      />
    </v-col>
  </v-row>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import AssistChat from './AssistChat.vue';

const chatRef = ref<InstanceType<typeof AssistChat> | null>(null);
const anchorEntries = ref<Array<{ key: string; id: string }>>([]);
</script>

<style>
.h-100 { height: 100%; }
</style>



-------------------------------------------------------------------------- Sidebar Delete Icon -------------------------------------------------------------------

/** Find the user bubble index for an anchorId and the index of the next bot bubble after it. */
function findIndicesForAnchor(anchorId: string): { userIdx: number; botIdx: number | null } {
  const userIdx = messages.value.findIndex(
    (m) => m.sender === 'user' && m.anchorId === anchorId
  );
  if (userIdx === -1) return { userIdx: -1, botIdx: null };

  const botIdx = messages.value.slice(userIdx + 1).findIndex((m) => m.sender === 'bot');
  return { userIdx, botIdx: botIdx === -1 ? null : userIdx + 1 + botIdx };
}

/** Remove all messages AFTER a given index; also prune anchor map accordingly. */
function truncateAfterIndex(keepThroughIdx: number) {
  if (keepThroughIdx >= messages.value.length - 1) return; // nothing to truncate

  // Build a set of anchorIds that will remain after truncation
  const remaining = new Set<string>();
  for (let i = 0; i <= keepThroughIdx; i++) {
    const m = messages.value[i];
    if (m.sender === 'user' && m.anchorId) remaining.add(m.anchorId);
  }

  // Truncate the chat
  messages.value.splice(keepThroughIdx + 1);

  // Prune anchorMap entries whose anchorId no longer exists
  for (const [key, id] of Array.from(anchorMap.entries())) {
    if (!remaining.has(id)) anchorMap.delete(key);
  }
  emitAnchorsUpdated();
}


/** Scroll to anchor id, then delete everything AFTER the related bot bubble. */
async function deleteAfterAnchorId(anchorId: string) {
  if (!anchorId) return;

  // 1) Scroll to the anchor so the user sees the context
  await scrollToAnchorId(anchorId, true);

  // 2) Compute indices and truncate after the related bot bubble
  const { userIdx, botIdx } = findIndicesForAnchor(anchorId);
  if (userIdx === -1) return;

  // If no bot bubble after that user, keep only up to the user bubble
  const cutAt = botIdx != null ? botIdx : userIdx;
  truncateAfterIndex(cutAt);

  // Optional: refocus the input afterwards
  await nextTick();
  focusInput();
}

/** Convenience for sidebar: provide a key (user text or href) instead of id. */
async function deleteAfterAnchorByKey(key: string) {
  const id = anchorMap.get(key);
  if (!id) return;
  await deleteAfterAnchorId(id);
}



<template>
  <v-list density="compact" lines="one">
    <v-list-item
      v-for="(e, i) in anchorEntries"
      :key="i"
      @click="chatRef?.scrollToAnchorByKey(e.key)"
    >
      <v-list-item-title class="truncate">{{ e.key }}</v-list-item-title>

      <template #append>
        <v-btn
          icon
          size="x-small"
          variant="text"
          color="error"
          @click.stop="chatRef?.deleteAfterAnchorByKey(e.key)"
          :aria-label="`Delete after ${e.key}`"
        >
          <v-icon>mdi-delete-outline</v-icon>
        </v-btn>
      </template>
    </v-list-item>
  </v-list>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import AssistChat from './AssistChat.vue';

const chatRef = ref<InstanceType<typeof AssistChat> | null>(null);
const anchorEntries = ref<Array<{ key: string; id: string }>>([]);

// Listen for updates from AssistChat.vue
function onAnchorsUpdated(list: Array<{ key: string; id: string }>) {
  anchorEntries.value = list;
}
</script>

------------------------------------- Template: add an icon before “Score"  ----------------------------------------------------
<!-- inside the bot bubble, where you render e in m.entries -->
<div class="entry-line">
  <!-- NEW thumbs-up icon -->
  <v-btn
    size="x-small"
    variant="text"
    density="comfortable"
    class="mr-2"
    @click="onThumbsUpForMessageIndex(mIdx)"
    :aria-label="'Thumbs up for this answer'"
  >
    <v-icon>mdi-thumb-up-outline</v-icon>
  </v-btn>

  <span class="font-weight-bold">Score: {{ e.score }}</span>
  <span>&nbsp;</span>

  <!-- existing segments rendering follows... -->
  <template v-for="(seg, k) in e.textSegments" :key="k">
    <span v-if="seg.type === 'text'">{{ seg.text }}</span>
    <v-btn
      v-else
      variant="text"
      density="compact"
      class="px-0 link-underline link-bold"
      @click="onLinkClick((seg as LinkSegment).href)"
    >
      {{ (seg as LinkSegment).text }}
    </v-btn>
  </template>
</div>

Note: your outer v-for over messages should expose the index so you can resolve the “previous user”:

<template v-for="(m, mIdx) in messages" :key="m.id">
  <!-- ... -->
</template>

/**
 * Walk backward from a given message index to find the nearest
 * previous 'user' bubble and return its raw text.
 */
function findPreviousUserText(msgIndex: number): string | null {
  for (let i = msgIndex - 1; i >= 0; i--) {
    const m = messages.value[i];
    if (m?.sender === 'user') {
      const raw = (m.raw ?? '').toString().trim();
      return raw.length ? raw : null;
    }
  }
  return null;
}

/**
 * Public handler for thumbs-up on a bot entry. Resolves previous user text,
 * then delegates to your integration hook.
 */
function onThumbsUpForMessageIndex(msgIndex: number) {
  const prevUserText = findPreviousUserText(msgIndex);
  if (!prevUserText) {
    // No previous user prompt found; you can no-op or toast here.
    return;
  }
  handleThumbsUp(prevUserText);
}

/**
 * Integration hook: send the previous user prompt to your backend, or
 * emit an event so the parent can do it. Replace the emit with your call.
 */
function handleThumbsUp(previousUserPrompt: string) {
  // Example 1: emit to parent (recommended for clean separation)
  // emit('thumbs-up', previousUserPrompt);

  // Example 2: call your own client API directly (pseudo-code)
  // feedbackApi.sendThumbsUp({ prompt: previousUserPrompt });

  // For now we’ll just log so you can see it wire up:
  // eslint-disable-next-line no-console
  console.log('ThumbsUp previous user prompt:', previousUserPrompt);
}


/* optional: tighter icon spacing before Score */
.entry-line .v-btn.mr-2 {
  margin-right: 8px !important;
}

-------------------------------------- Sub Queruries ----------------------------------------------

// Request from UI
public record SemanticSearchRequest(
    String text,
    Integer topK,
    Double scoreThreshold,
    Boolean searchIncidents,    // default true (initial search only)
    Boolean searchRequests,     // default true
    Boolean searchConfluence,   // default true
    Integer promptId,           // client sends 0 to start a new session flow
    String userSessionName      // required to scope per-user caches
) {}

// Response items
public record SearchResultItem(
    Integer promptId,           // batch id assigned by server for THIS response
    String sourceTable,
    String id,
    String name,
    Double bqScore,             // original BQ similarity (0..1); null for pure summary-only flows
    Double summaryScore,        // follow-up similarity (0..1) between new query and stored summary; null in initial batch
    String summary,             // <= 250 chars including suffix
    Map<String, Object> fields  // non-embedding metadata from base + *Text tables
) {}

// Response wrapper
public record SemanticSearchResponse(
    Integer promptId,           // the new promptId the server assigned for THIS call
    List<SearchResultItem> results
) {}



package com.example.search;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.cloud.bigquery.*;
import org.springframework.ai.embedding.Embedding;
import org.springframework.ai.embedding.EmbeddingModel;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.messages.SystemMessage;
import org.springframework.ai.chat.messages.UserMessage;
import org.springframework.ai.chat.model.ChatResponse;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

@Service
public class SemanticSearchService {

    // ---- Config knobs ----
    private static final String JOB_LOCATION = "us-central1";
    private static final int MAX_SUMMARY_CHARS = 250;
    private static final int MAX_PROMPTS_PER_SESSION = 25;
    private static final Duration SESSION_TTL = Duration.ofMinutes(30);

    private final EmbeddingModel embeddingModel; // Vertex AI text-embedding-004
    private final BigQuery bigQuery;
    private final ChatClient chatClient;         // Vertex AI Gemini
    private final ObjectMapper om = new ObjectMapper();

    public SemanticSearchService(EmbeddingModel embeddingModel,
                                 BigQuery bigQuery,
                                 ChatClient chatClient) {
        this.embeddingModel = embeddingModel;
        this.bigQuery = bigQuery;
        this.chatClient = chatClient;
    }

    // ====== Public entrypoint ======
    public SemanticSearchResponse searchAndSummarize(SemanticSearchRequest req) {
        // --- Validate + defaults
        String query = Optional.ofNullable(req.text()).orElse("").trim();
        if (!StringUtils.hasText(query)) {
            return new SemanticSearchResponse(0, List.of());
        }
        int topK = Optional.ofNullable(req.topK()).orElse(10);
        Double threshold = req.scoreThreshold(); // may be null
        boolean inc  = req.searchIncidents()  == null ? true : req.searchIncidents();
        boolean rq   = req.searchRequests()   == null ? true : req.searchRequests();
        boolean conf = req.searchConfluence() == null ? true : req.searchConfluence();
        String session = Optional.ofNullable(req.userSessionName()).orElse("default");

        // --- Evict stale sessions once per call
        evictStaleSessions();

        // --- Get/create session state
        SessionState state = sessions.computeIfAbsent(session, k -> new SessionState());
        state.touch();

        int incomingPromptId = Optional.ofNullable(req.promptId()).orElse(0);

        if (incomingPromptId == 0 || state.isEmpty()) {
            // ============ INITIAL FLOW: BigQuery TVF search ============
            int newPromptId = state.nextPromptId();
            List<CachedItem> cached = runInitialSearchAndSummarize(query, topK, threshold, inc, rq, conf);
            // store with embeddings of summaries for future follow-ups
            for (CachedItem item : cached) {
                item.promptId = newPromptId;
                item.summaryEmbedding = l2normalize(embed(item.summary)); // embed summary text
            }
            state.addBatch(newPromptId, cached);
            state.enforcePromptLimit(MAX_PROMPTS_PER_SESSION);

            List<SearchResultItem> out = cached.stream().map(ci -> new SearchResultItem(
                newPromptId, ci.sourceTable, ci.id, ci.name, ci.bqScore, null, ci.summary, ci.fields
            )).toList();

            return new SemanticSearchResponse(newPromptId, out);
        } else {
            // ============ FOLLOW-UP FLOW: search over prior summaries ============
            int newPromptId = state.nextPromptId();

            // Gather candidates with promptId <= incomingPromptId
            List<CachedItem> candidates = state.itemsUpTo(incomingPromptId);
            if (candidates.isEmpty()) {
                // Fallback to initial flow if somehow empty
                return searchAndSummarize(new SemanticSearchRequest(query, topK, threshold, inc, rq, conf, 0, session));
            }

            // Embed new query (normalized)
            List<Double> q = l2normalize(embed(query));

            // Score by cosine (dot) against each summary embedding
            List<ScoredItem> scored = new ArrayList<>();
            for (CachedItem c : candidates) {
                if (c.summaryEmbedding == null || c.summaryEmbedding.isEmpty()) continue;
                double score = cosineSimilarity(q, c.summaryEmbedding);
                if (threshold == null || score >= threshold) {
                    scored.add(new ScoredItem(c, score));
                }
            }

            // Take topK by summaryScore
            scored.sort((a, b) -> Double.compare(b.summaryScore, a.summaryScore));
            if (scored.size() > topK) scored = scored.subList(0, topK);

            // Re-summarize (focused on new query) and store this new batch (with embeddings)
            List<CachedItem> newBatch = new ArrayList<>();
            for (ScoredItem si : scored) {
                CachedItem base = si.base;
                String focused = summarizeFocused(base.sourceTable, base.id, base.name, base.fields, query);
                String finalSummary = capWithScores(focused, base.bqScore, si.summaryScore);

                CachedItem copy = base.copy(); // shallow copy fields map
                copy.promptId = newPromptId;
                copy.summary = finalSummary;
                copy.summaryEmbedding = l2normalize(embed(finalSummary)); // store for later follow-ups
                // Keep original bqScore
                newBatch.add(copy);
            }

            state.addBatch(newPromptId, newBatch);
            state.enforcePromptLimit(MAX_PROMPTS_PER_SESSION);

            List<SearchResultItem> out = newBatch.stream().map(ci -> new SearchResultItem(
                newPromptId, ci.sourceTable, ci.id, ci.name, ci.bqScore, // keep original BQ score
                // pull summary score by recomputing (or from the scored list map)
                cosineSimilarity(q, ci.summaryEmbedding),
                ci.summary, ci.fields
            )).toList();

            return new SemanticSearchResponse(newPromptId, out);
        }
    }

    // ====== INITIAL: TVF + base summaries ======
    private List<CachedItem> runInitialSearchAndSummarize(String query, int topK, Double threshold,
                                                          boolean inc, boolean rq, boolean conf) {
        // Embed + normalize query for TVF
        List<Double> q = l2normalize(embed(query));

        // Call TVF (returns source_table,id,name,score,base)
        TableResult rows = callTvf(q, topK, threshold, inc, rq, conf);

        // Schema ref to parse the base struct
        Field baseField = rows.getSchema().getFields().get("base");
        FieldList baseSubs = baseField.getSubFields();

        List<CachedItem> out = new ArrayList<>();
        for (FieldValueList r : rows.iterateAll()) {
            String sourceTable = r.get("source_table").getStringValue();
            String id   = r.get("id").getStringValue();
            String name = r.get("name").isNull() ? "" : r.get("name").getStringValue();
            double bqScore = r.get("score").getDoubleValue();
            Map<String,Object> fields = toMap(r.get("base"), baseSubs);

            // Generic concise summary (not focused)
            String summaryRaw = summarizeGeneric(sourceTable, id, name, fields);
            String summary = capWithScores(summaryRaw, bqScore, null);

            CachedItem item = new CachedItem();
            item.sourceTable = sourceTable;
            item.id = id;
            item.name = name;
            item.fields = fields;
            item.bqScore = bqScore;
            item.summary = summary;
            out.add(item);
        }
        return out;
    }

    private TableResult callTvf(List<Double> q, int topK, Double threshold,
                                boolean inc, boolean rq, boolean conf) {
        String sql = """
            SELECT source_table, id, name, score, base
            FROM `myproj.mydata.semantic_search_all`(
              q => @q, topK => @topK, threshold => @threshold,
              search_incidents => @inc, search_requests => @req, search_confluence => @conf
            )
            """;

        Map<String, QueryParameterValue> params = new HashMap<>();
        params.put("q", QueryParameterValue.array(q.toArray(new Double[0]), StandardSQLTypeName.FLOAT64));
        params.put("topK", QueryParameterValue.int64(topK));
        params.put("threshold", threshold == null
            ? QueryParameterValue.nullOf(StandardSQLTypeName.FLOAT64)
            : QueryParameterValue.float64(threshold));
        params.put("inc", QueryParameterValue.bool(inc));
        params.put("req", QueryParameterValue.bool(rq));
        params.put("conf", QueryParameterValue.bool(conf));

        QueryJobConfiguration qjc = QueryJobConfiguration.newBuilder(sql)
            .setUseLegacySql(false)
            .setNamedParameters(params)
            .build();

        JobId jobId = JobId.newBuilder().setLocation(JOB_LOCATION).build();
        Job job = bigQuery.create(JobInfo.newBuilder(qjc).setJobId(jobId).build());

        try {
            job = job.waitFor();
            if (job == null) throw new RuntimeException("Job disappeared");
            if (job.getStatus().getError() != null) {
                throw new RuntimeException(job.getStatus().getError().toString());
            }
            return job.getQueryResults();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }
    }

    // ====== Summarizers (generic & focused) with 250-char cap ======
    private String summarizeGeneric(String sourceTable, String id, String name, Map<String, Object> fields) {
        String content = buildPreferredContent(sourceTable, fields);
        String system = """
            You are a concise summarizer for incidents/requests/confluence notes.
            Return one sentence, factual, no speculation, no lists.
            HARD LIMIT: <= 220 characters.
            """;
        String user = "Source=%s, id=%s, name=%s\n\nContent:\n%s".formatted(sourceTable, id, name, content);
        String raw = chatClient.prompt(new SystemMessage(system)).prompt(new UserMessage(user)).call().content();
        return normalizeWhitespace(raw);
    }

    private String summarizeFocused(String sourceTable, String id, String name, Map<String, Object> fields, String query) {
        String content = buildPreferredContent(sourceTable, fields);
        String system = """
            You are a concise summarizer that answers a follow-up query about prior results.
            Focus ONLY on details relevant to the user's new query.
            Return one sentence, factual, no speculation, no lists.
            HARD LIMIT: <= 220 characters.
            """;
        String user = "UserQuery=%s\nSource=%s, id=%s, name=%s\n\nContent:\n%s"
            .formatted(query, sourceTable, id, name, content);
        String raw = chatClient.prompt(new SystemMessage(system)).prompt(new UserMessage(user)).call().content();
        return normalizeWhitespace(raw);
    }

    private static String buildPreferredContent(String sourceTable, Map<String, Object> fields) {
        List<String> keys = switch (sourceTable) {
            case "TableIncidents"  -> List.of("error_text","solution_text","incName");
            case "TableIRequests"  -> List.of("description_text","notes_text","reqName");
            case "TableConfluence" -> List.of("confluence_data_text","confluence_contacts_text","nameConfluence");
            default -> List.of();
        };
        StringBuilder sb = new StringBuilder();
        for (String k : keys) {
            Object v = fields.get(k);
            if (v instanceof String s && !s.isBlank()) {
                sb.append(k).append(": ")
                  .append(s.length() > 4000 ? s.substring(0, 4000) + "…" : s)
                  .append("\n");
            }
        }
        if (sb.length() == 0) sb.append(fields);
        return sb.toString();
    }

    // Compose final summary <= 250 chars, appending scores that exist
    private static String capWithScores(String content, Double bqScore, Double summaryScore) {
        String suffix;
        if (bqScore != null && summaryScore != null) {
            suffix = String.format(" (bq: %.3f, sum: %.3f)", bqScore, summaryScore);
        } else if (bqScore != null) {
            suffix = String.format(" (bq: %.3f)", bqScore);
        } else if (summaryScore != null) {
            suffix = String.format(" (sum: %.3f)", summaryScore);
        } else {
            suffix = "";
        }

        String norm = normalizeWhitespace(content);
        int maxContent = Math.max(0, MAX_SUMMARY_CHARS - suffix.length());
        String capped = truncateToLength(norm, maxContent);
        return capped + suffix;
    }

    // ====== Embedding + similarity utils ======
    private List<Double> embed(String text) {
        List<Embedding> res = embeddingModel.embed(List.of(text)).getResults();
        if (res.isEmpty()) throw new IllegalStateException("No embedding returned");
        return res.get(0).getOutput();
    }

    private static List<Double> l2normalize(List<Double> v) {
        double n = Math.sqrt(v.stream().mapToDouble(x -> x*x).sum());
        if (n == 0) return v;
        return v.stream().map(x -> x / n).collect(Collectors.toList());
    }

    private static double cosineSimilarity(List<Double> a, List<Double> b) {
        int n = Math.min(a.size(), b.size());
        double dot = 0.0;
        for (int i = 0; i < n; i++) dot += a.get(i) * b.get(i);
        // a and b are normalized already -> dot in [-1,1], clamp to [0,1] similarity
        double sim = Math.max(-1.0, Math.min(1.0, dot));
        return (sim + 1.0) / 2.0; // optional: map to 0..1; remove if you prefer raw cosine
    }

    private static String normalizeWhitespace(String s) {
        if (s == null) return "";
        return s.replaceAll("\\s+", " ").trim();
    }

    private static String truncateToLength(String s, int maxChars) {
        if (s == null) return "";
        if (s.length() <= maxChars) return s;
        int end = Math.max(0, Math.min(s.length(), maxChars));
        int cut = s.lastIndexOf(' ', end);
        if (cut >= 0 && cut >= end - 40) end = cut;
        String base = s.substring(0, end).trim();
        return base.length() < s.length() ? base + "…" : base;
    }

    // ====== RECORD parsing ======
    private Map<String, Object> toMap(FieldValue base, FieldList subFields) {
        FieldValueList rec = base.getRecordValue();
        Map<String, Object> out = new LinkedHashMap<>();
        for (int i = 0; i < subFields.size(); i++) {
            Field f = subFields.get(i);
            FieldValue v = rec.get(i);
            Object val = v.isNull() ? null : switch (f.getType().getStandardType()) {
                case STRING  -> v.getStringValue();
                case INT64   -> v.getLongValue();
                case FLOAT64 -> v.getDoubleValue();
                case BOOL    -> v.getBooleanValue();
                default      -> v.getStringValue();
            };
            out.put(f.getName(), val);
        }
        return out;
    }

    // ====== Session cache ======
    private static class CachedItem {
        Integer promptId;                 // origin batch id
        String sourceTable;
        String id;
        String name;
        Double bqScore;                   // from BQ initial search
        String summary;                   // <= 250 chars
        List<Double> summaryEmbedding;    // normalized embedding of 'summary'
        Map<String, Object> fields;

        CachedItem copy() {
            CachedItem c = new CachedItem();
            c.promptId = this.promptId;
            c.sourceTable = this.sourceTable;
            c.id = this.id;
            c.name = this.name;
            c.bqScore = this.bqScore;
            c.summary = this.summary;
            c.summaryEmbedding = this.summaryEmbedding == null ? null : new ArrayList<>(this.summaryEmbedding);
            c.fields = this.fields == null ? Map.of() : new LinkedHashMap<>(this.fields);
            return c;
        }
    }

    private static class ScoredItem {
        final CachedItem base;
        final double summaryScore;
        ScoredItem(CachedItem base, double s) { this.base = base; this.summaryScore = s; }
    }

    private static class SessionState {
        private final NavigableMap<Integer, List<CachedItem>> batches = new TreeMap<>();
        private final AtomicInteger counter = new AtomicInteger(0);
        private Instant lastAccess = Instant.now();

        void touch() { lastAccess = Instant.now(); }
        boolean isEmpty() { return batches.isEmpty(); }
        int nextPromptId() { return counter.incrementAndGet(); }

        void addBatch(int promptId, List<CachedItem> items) {
            batches.put(promptId, items);
        }

        List<CachedItem> itemsUpTo(int promptIdInclusive) {
            List<CachedItem> all = new ArrayList<>();
            for (Map.Entry<Integer, List<CachedItem>> e : batches.headMap(promptIdInclusive, true).entrySet()) {
                all.addAll(e.getValue());
            }
            return all;
        }

        void enforcePromptLimit(int maxPrompts) {
            while (batches.size() > maxPrompts) {
                Integer oldest = batches.firstKey();
                batches.remove(oldest);
            }
        }

        boolean isExpired() {
            return Instant.now().isAfter(lastAccess.plus(SESSION_TTL));
        }
    }

    private final ConcurrentHashMap<String, SessionState> sessions = new ConcurrentHashMap<>();

    private void evictStaleSessions() {
        for (Map.Entry<String, SessionState> e : sessions.entrySet()) {
            if (e.getValue().isExpired()) {
                sessions.remove(e.getKey());
            }
        }
    }
}





