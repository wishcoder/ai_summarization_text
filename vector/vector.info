============ SQL TVF ============

-- Location: us-central1
-- Creates a table-valued function you can call like:
-- SELECT * FROM `myproj.mydata.semantic_search_all`(q => <ARRAY<FLOAT64>>, topK => 30, threshold => 0.7,
--                                                   search_incidents => TRUE, search_requests => TRUE, search_confluence => TRUE);

CREATE OR REPLACE FUNCTION `myproj.mydata.semantic_search_all`(
  q ARRAY<FLOAT64>,         -- 768-D query embedding (L2-normalized in Java to match stored vectors)
  topK INT64,               -- per-branch top_k (applied inside each VECTOR_SEARCH)
  threshold FLOAT64,        -- nullable; set NULL to disable score filtering
  search_incidents BOOL,    -- toggle Incidents
  search_requests BOOL,     -- toggle IRequests
  search_confluence BOOL    -- toggle Confluence
)
RETURNS TABLE<
  source_table STRING,
  id           STRING,
  name         STRING,
  score        FLOAT64,
  base         STRUCT<
    -- Unioned "base" schema so the TVF has a stable result type across all three sources.
    -- For rows that don't use a field, it will be NULL.
    incId                      STRING,
    incName                    STRING,
    reqId                      STRING,
    reqName                    STRING,
    idConfluence               STRING,
    nameConfluence             STRING,
    -- Paired *Text table fields (for summarization)
    error_text                 STRING,
    solution_text              STRING,
    description_text           STRING,
    notes_text                 STRING,
    confluence_data_text       STRING,
    confluence_contacts_text   STRING
  >
)
AS (
  WITH query_vec AS (SELECT q AS emb),

  -- ================== Incidents (embedding_error / embedding_solution) ==================
  inc_union AS (
    SELECT 'TableIncidents' AS source_table, base.incId AS id, base.incName AS name, distance, base
    FROM VECTOR_SEARCH(
      TABLE `myproj.mydata.TableIncidents`,
      'embedding_error',
      (SELECT emb FROM query_vec), 'emb',
      top_k => topK, distance_type => 'COSINE', options => '{}'
    )
    UNION ALL
    SELECT 'TableIncidents', base.incId, base.incName, distance, base
    FROM VECTOR_SEARCH(
      TABLE `myproj.mydata.TableIncidents`,
      'embedding_solution',
      (SELECT emb FROM query_vec), 'emb',
      top_k => topK, distance_type => 'COSINE', options => '{}'
    )
  ),
  inc_best AS (
    SELECT source_table, id, name, MIN(distance) AS best_distance
    FROM inc_union
    GROUP BY source_table, id, name
  ),
  inc_joined AS (
    SELECT
      b.source_table,
      b.id,
      b.name,
      -- Build the unioned STRUCT explicitly so schemas match across UNION ALL later.
      STRUCT(
        i.incId,
        i.incName,
        CAST(NULL AS STRING) AS reqId,
        CAST(NULL AS STRING) AS reqName,
        CAST(NULL AS STRING) AS idConfluence,
        CAST(NULL AS STRING) AS nameConfluence,
        it.embedding_error_text,
        it.embedding_solution_text,
        CAST(NULL AS STRING) AS description_text,
        CAST(NULL AS STRING) AS notes_text,
        CAST(NULL AS STRING) AS confluence_data_text,
        CAST(NULL AS STRING) AS confluence_contacts_text
      ) AS base,
      LEAST(GREATEST(1.0 - b.best_distance, 0.0), 1.0) AS score
    FROM inc_best b
    JOIN `myproj.mydata.TableIncidents` i
      ON i.incId = b.id
    LEFT JOIN `myproj.mydata.TableIncidentsText` it
      ON it.incId = b.id
  ),

  -- ================== IRequests (embedding_description / embedding_notes) ==================
  req_union AS (
    SELECT 'TableIRequests', base.reqId, base.reqName, distance, base
    FROM VECTOR_SEARCH(
      TABLE `myproj.mydata.TableIRequests`,
      'embedding_description',
      (SELECT emb FROM query_vec), 'emb',
      top_k => topK, distance_type => 'COSINE', options => '{}'
    )
    UNION ALL
    SELECT 'TableIRequests', base.reqId, base.reqName, distance, base
    FROM VECTOR_SEARCH(
      TABLE `myproj.mydata.TableIRequests`,
      'embedding_notes',
      (SELECT emb FROM query_vec), 'emb',
      top_k => topK, distance_type => 'COSINE', options => '{}'
    )
  ),
  req_best AS (
    SELECT source_table, id, name, MIN(distance) AS best_distance
    FROM req_union
    GROUP BY source_table, id, name
  ),
  req_joined AS (
    SELECT
      b.source_table,
      b.id,
      b.name,
      STRUCT(
        CAST(NULL AS STRING) AS incId,
        CAST(NULL AS STRING) AS incName,
        r.reqId,
        r.reqName,
        CAST(NULL AS STRING) AS idConfluence,
        CAST(NULL AS STRING) AS nameConfluence,
        CAST(NULL AS STRING) AS error_text,
        CAST(NULL AS STRING) AS solution_text,
        rt.embedding_description_text,
        rt.embedding_notes_text,
        CAST(NULL AS STRING) AS confluence_data_text,
        CAST(NULL AS STRING) AS confluence_contacts_text
      ) AS base,
      LEAST(GREATEST(1.0 - b.best_distance, 0.0), 1.0) AS score
    FROM req_best b
    JOIN `myproj.mydata.TableIRequests` r
      ON r.reqId = b.id
    LEFT JOIN `myproj.mydata.TableIRequestsText` rt
      ON rt.reqId = b.id
  ),

  -- ================== Confluence (embedding_confluence_data / embedding_confluence_contacts) ==================
  conf_union AS (
    SELECT 'TableConfluence', base.idConfluence, base.nameConfluence, distance, base
    FROM VECTOR_SEARCH(
      TABLE `myproj.mydata.TableConfluence`,
      'embedding_confluence_data',
      (SELECT emb FROM query_vec), 'emb',
      top_k => topK, distance_type => 'COSINE', options => '{}'
    )
    UNION ALL
    SELECT 'TableConfluence', base.idConfluence, base.nameConfluence, distance, base
    FROM VECTOR_SEARCH(
      TABLE `myproj.mydata.TableConfluence`,
      'embedding_confluence_contacts',
      (SELECT emb FROM query_vec), 'emb',
      top_k => topK, distance_type => 'COSINE', options => '{}'
    )
  ),
  conf_best AS (
    SELECT source_table, id, name, MIN(distance) AS best_distance
    FROM conf_union
    GROUP BY source_table, id, name
  ),
  conf_joined AS (
    SELECT
      b.source_table,
      b.id,
      b.name,
      STRUCT(
        CAST(NULL AS STRING) AS incId,
        CAST(NULL AS STRING) AS incName,
        CAST(NULL AS STRING) AS reqId,
        CAST(NULL AS STRING) AS reqName,
        c.idConfluence,
        c.nameConfluence,
        CAST(NULL AS STRING) AS error_text,
        CAST(NULL AS STRING) AS solution_text,
        CAST(NULL AS STRING) AS description_text,
        CAST(NULL AS STRING) AS notes_text,
        ct.embedding_confluence_data_text,
        ct.embedding_confluence_contacts_text
      ) AS base,
      LEAST(GREATEST(1.0 - b.best_distance, 0.0), 1.0) AS score
    FROM conf_best b
    JOIN `myproj.mydata.TableConfluence` c
      ON c.idConfluence = b.id
    LEFT JOIN `myproj.mydata.TableConfluenceText` ct
      ON ct.idConfluence = b.id
  )

  -- ================== Merge with flags & threshold; NO final LIMIT (per your choice) ==================
  SELECT source_table, id, name, score, base
  FROM (
    SELECT * FROM inc_joined  WHERE search_incidents
    UNION ALL
    SELECT * FROM req_joined  WHERE search_requests
    UNION ALL
    SELECT * FROM conf_joined WHERE search_confluence
  )
  WHERE threshold IS NULL OR score >= threshold
  ORDER BY score DESC
);

============ SQL ============
-- Location: us-central1
-- Params: @q ARRAY<FLOAT64>, @topK INT64, @threshold FLOAT64 (nullable)

WITH query_vec AS (SELECT @q AS emb),

-- ----------- Incidents: error / solution -----------
inc_union AS (
  SELECT 'TableIncidents' AS source_table, base.incId AS id, base.incName AS name, distance, base
  FROM VECTOR_SEARCH(
    TABLE `myproj.mydata.TableIncidents`,
    'embedding_error',
    (SELECT emb FROM query_vec), 'emb',
    top_k => @topK, distance_type => 'COSINE', options => '{}'
  )
  UNION ALL
  SELECT 'TableIncidents', base.incId, base.incName, distance, base
  FROM VECTOR_SEARCH(
    TABLE `myproj.mydata.TableIncidents`,
    'embedding_solution',
    (SELECT emb FROM query_vec), 'emb',
    top_k => @topK, distance_type => 'COSINE', options => '{}'
  )
),
inc_best AS (
  SELECT source_table, id, name, MIN(distance) AS best_distance
  FROM inc_union
  GROUP BY source_table, id, name
),
inc_joined AS (
  SELECT
    b.source_table,
    b.id,
    b.name,
    STRUCT(
      i.* EXCEPT (embedding_error, embedding_solution),
      it.embedding_error_text     AS error_text,
      it.embedding_solution_text  AS solution_text
    ) AS base,
    LEAST(GREATEST(1.0 - b.best_distance, 0.0), 1.0) AS score
  FROM inc_best b
  JOIN `myproj.mydata.TableIncidents` i
    ON i.incId = b.id
  LEFT JOIN `myproj.mydata.TableIncidentsText` it
    ON it.incId = b.id
),

-- ----------- IRequests: description / notes -----------
req_union AS (
  SELECT 'TableIRequests', base.reqId, base.reqName, distance, base
  FROM VECTOR_SEARCH(
    TABLE `myproj.mydata.TableIRequests`,
    'embedding_description',
    (SELECT emb FROM query_vec), 'emb',
    top_k => @topK, distance_type => 'COSINE', options => '{}'
  )
  UNION ALL
  SELECT 'TableIRequests', base.reqId, base.reqName, distance, base
  FROM VECTOR_SEARCH(
    TABLE `myproj.mydata.TableIRequests`,
    'embedding_notes',
    (SELECT emb FROM query_vec), 'emb',
    top_k => @topK, distance_type => 'COSINE', options => '{}'
  )
),
req_best AS (
  SELECT source_table, id, name, MIN(distance) AS best_distance
  FROM req_union
  GROUP BY source_table, id, name
),
req_joined AS (
  SELECT
    b.source_table,
    b.id,
    b.name,
    STRUCT(
      r.* EXCEPT (embedding_description, embedding_notes),
      rt.embedding_description_text AS description_text,
      rt.embedding_notes_text       AS notes_text
    ) AS base,
    LEAST(GREATEST(1.0 - b.best_distance, 0.0), 1.0) AS score
  FROM req_best b
  JOIN `myproj.mydata.TableIRequests` r
    ON r.reqId = b.id
  LEFT JOIN `myproj.mydata.TableIRequestsText` rt
    ON rt.reqId = b.id
),

-- ----------- Confluence: data / contacts -----------
conf_union AS (
  SELECT 'TableConfluence', base.idConfluence, base.nameConfluence, distance, base
  FROM VECTOR_SEARCH(
    TABLE `myproj.mydata.TableConfluence`,
    'embedding_confluence_data',
    (SELECT emb FROM query_vec), 'emb',
    top_k => @topK, distance_type => 'COSINE', options => '{}'
  )
  UNION ALL
  SELECT 'TableConfluence', base.idConfluence, base.nameConfluence, distance, base
  FROM VECTOR_SEARCH(
    TABLE `myproj.mydata.TableConfluence`,
    'embedding_confluence_contacts',
    (SELECT emb FROM query_vec), 'emb',
    top_k => @topK, distance_type => 'COSINE', options => '{}'
  )
),
conf_best AS (
  SELECT source_table, id, name, MIN(distance) AS best_distance
  FROM conf_union
  GROUP BY source_table, id, name
),
conf_joined AS (
  SELECT
    b.source_table,
    b.id,
    b.name,
    STRUCT(
      c.* EXCEPT (embedding_confluence_data, embedding_confluence_contacts),
      ct.embedding_confluence_data_text     AS confluence_data_text,
      ct.embedding_confluence_contacts_text AS confluence_contacts_text
    ) AS base,
    LEAST(GREATEST(1.0 - b.best_distance, 0.0), 1.0) AS score
  FROM conf_best b
  JOIN `myproj.mydata.TableConfluence` c
    ON c.idConfluence = b.id
  LEFT JOIN `myproj.mydata.TableConfluenceText` ct
    ON ct.idConfluence = b.id
),

-- ----------- Merge, filter, order -----------
all_scored AS (
  SELECT * FROM inc_joined
  UNION ALL SELECT * FROM req_joined
  UNION ALL SELECT * FROM conf_joined
)
SELECT
  source_table,
  id,
  name,
  base,
  TO_JSON(base) AS base_json,
  score
FROM all_scored
WHERE @threshold IS NULL OR score >= @threshold
ORDER BY score DESC
LIMIT @topK;


============ Java ============

// Request from UI
public record SemanticSearchRequest(
    String text,
    Integer topK,
    Double scoreThreshold
) {}

// Response items
public record SearchResultItem(
    String sourceTable,
    String id,
    String name,
    double score,               // 0..1
    String summary,             // ends with "(score: 0.###)"
    Map<String, Object> fields  // all non-embedding cols incl. *_text from *Text tables
) {}

public record SemanticSearchResponse(
    List<SearchResultItem> results
) {}

-----------------------------------------------------------------

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.cloud.bigquery.*;
import org.springframework.ai.embedding.Embedding;
import org.springframework.ai.embedding.EmbeddingModel;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.messages.SystemMessage;
import org.springframework.ai.chat.messages.UserMessage;
import org.springframework.ai.chat.model.ChatResponse;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.util.*;
import java.util.stream.Collectors;

@Service
public class SemanticSearchService {

    private final EmbeddingModel embeddingModel;
    private final BigQuery bigQuery;
    private final ChatClient chatClient;
    private final ObjectMapper om = new ObjectMapper();

    public SemanticSearchService(EmbeddingModel embeddingModel,
                                 BigQuery bigQuery,
                                 ChatClient chatClient) {
        this.embeddingModel = embeddingModel;
        this.bigQuery = bigQuery;
        this.chatClient = chatClient;
    }

    public SemanticSearchResponse searchAndSummarize(SemanticSearchRequest req) {
        String text = Objects.requireNonNullElse(req.text(), "").trim();
        if (!StringUtils.hasText(text)) {
            return new SemanticSearchResponse(List.of());
        }

        // 1) Embed query text and L2-normalize (your stored vectors are normalized)
        List<Double> vec = embed(text);
        List<Double> q = l2normalize(vec);

        int topK = req.topK() != null ? req.topK() : 10;
        Double threshold = req.scoreThreshold(); // nullable

        // 2) Run BigQuery
        TableResult rows = runBigQuery(q, topK, threshold);

        // 3) Build results with per-row summarization
        List<SearchResultItem> items = new ArrayList<>();
        for (FieldValueList row : rows.iterateAll()) {
            String sourceTable = row.get("source_table").getStringValue();
            String id = row.get("id").getStringValue();
            String name = row.get("name").isNull() ? "" : row.get("name").getStringValue();
            double score = row.get("score").getDoubleValue();
            Map<String, Object> fields = parseBaseJson(row.get("base_json").getStringValue());

            String summary = summarize(sourceTable, id, name, fields)
                    + String.format(" (score: %.3f)", score);

            items.add(new SearchResultItem(sourceTable, id, name, score, summary, fields));
        }
        return new SemanticSearchResponse(items);
    }

    private List<Double> embed(String text) {
        List<Embedding> res = embeddingModel.embed(List.of(text)).getResults();
        if (res.isEmpty()) throw new IllegalStateException("No embedding returned");
        return res.get(0).getOutput();
    }

    private static List<Double> l2normalize(List<Double> v) {
        double n = Math.sqrt(v.stream().mapToDouble(x -> x*x).sum());
        if (n == 0) return v;
        return v.stream().map(x -> x / n).collect(Collectors.toList());
    }

    private TableResult runBigQuery(List<Double> q, int topK, Double threshold) {
        String sql = """
            WITH query_vec AS (SELECT @q AS emb),
            inc_union AS (
              SELECT 'TableIncidents' AS source_table, base.incId AS id, base.incName AS name, distance, base
              FROM VECTOR_SEARCH(TABLE `myproj.mydata.TableIncidents`, 'embedding_error',
                                 (SELECT emb FROM query_vec), 'emb',
                                 top_k => @topK, distance_type => 'COSINE', options => '{}')
              UNION ALL
              SELECT 'TableIncidents', base.incId, base.incName, distance, base
              FROM VECTOR_SEARCH(TABLE `myproj.mydata.TableIncidents`, 'embedding_solution',
                                 (SELECT emb FROM query_vec), 'emb',
                                 top_k => @topK, distance_type => 'COSINE', options => '{}')
            ),
            inc_best AS (
              SELECT source_table, id, name, MIN(distance) AS best_distance
              FROM inc_union GROUP BY source_table, id, name
            ),
            inc_joined AS (
              SELECT b.source_table, b.id, b.name,
                     STRUCT(i.* EXCEPT (embedding_error, embedding_solution),
                            it.embedding_error_text AS error_text,
                            it.embedding_solution_text AS solution_text) AS base,
                     LEAST(GREATEST(1.0 - b.best_distance, 0.0), 1.0) AS score
              FROM inc_best b
              JOIN `myproj.mydata.TableIncidents` i ON i.incId = b.id
              LEFT JOIN `myproj.mydata.TableIncidentsText` it ON it.incId = b.id
            ),
            req_union AS (
              SELECT 'TableIRequests', base.reqId, base.reqName, distance, base
              FROM VECTOR_SEARCH(TABLE `myproj.mydata.TableIRequests`, 'embedding_description',
                                 (SELECT emb FROM query_vec), 'emb',
                                 top_k => @topK, distance_type => 'COSINE', options => '{}')
              UNION ALL
              SELECT 'TableIRequests', base.reqId, base.reqName, distance, base
              FROM VECTOR_SEARCH(TABLE `myproj.mydata.TableIRequests`, 'embedding_notes',
                                 (SELECT emb FROM query_vec), 'emb',
                                 top_k => @topK, distance_type => 'COSINE', options => '{}')
            ),
            req_best AS (
              SELECT source_table, id, name, MIN(distance) AS best_distance
              FROM req_union GROUP BY source_table, id, name
            ),
            req_joined AS (
              SELECT b.source_table, b.id, b.name,
                     STRUCT(r.* EXCEPT (embedding_description, embedding_notes),
                            rt.embedding_description_text AS description_text,
                            rt.embedding_notes_text AS notes_text) AS base,
                     LEAST(GREATEST(1.0 - b.best_distance, 0.0), 1.0) AS score
              FROM req_best b
              JOIN `myproj.mydata.TableIRequests` r ON r.reqId = b.id
              LEFT JOIN `myproj.mydata.TableIRequestsText` rt ON rt.reqId = b.id
            ),
            conf_union AS (
              SELECT 'TableConfluence', base.idConfluence, base.nameConfluence, distance, base
              FROM VECTOR_SEARCH(TABLE `myproj.mydata.TableConfluence`, 'embedding_confluence_data',
                                 (SELECT emb FROM query_vec), 'emb',
                                 top_k => @topK, distance_type => 'COSINE', options => '{}')
              UNION ALL
              SELECT 'TableConfluence', base.idConfluence, base.nameConfluence, distance, base
              FROM VECTOR_SEARCH(TABLE `myproj.mydata.TableConfluence`, 'embedding_confluence_contacts',
                                 (SELECT emb FROM query_vec), 'emb',
                                 top_k => @topK, distance_type => 'COSINE', options => '{}')
            ),
            conf_best AS (
              SELECT source_table, id, name, MIN(distance) AS best_distance
              FROM conf_union GROUP BY source_table, id, name
            ),
            conf_joined AS (
              SELECT b.source_table, b.id, b.name,
                     STRUCT(c.* EXCEPT (embedding_confluence_data, embedding_confluence_contacts),
                            ct.embedding_confluence_data_text AS confluence_data_text,
                            ct.embedding_confluence_contacts_text AS confluence_contacts_text) AS base,
                     LEAST(GREATEST(1.0 - b.best_distance, 0.0), 1.0) AS score
              FROM conf_best b
              JOIN `myproj.mydata.TableConfluence` c ON c.idConfluence = b.id
              LEFT JOIN `myproj.mydata.TableConfluenceText` ct ON ct.idConfluence = b.id
            ),
            all_scored AS (
              SELECT * FROM inc_joined
              UNION ALL SELECT * FROM req_joined
              UNION ALL SELECT * FROM conf_joined
            )
            SELECT source_table, id, name, base, TO_JSON(base) AS base_json, score
            FROM all_scored
            WHERE @threshold IS NULL OR score >= @threshold
            ORDER BY score DESC
            LIMIT @topK
            """;

        QueryJobConfiguration qjc = QueryJobConfiguration.newBuilder(sql)
            .setUseLegacySql(false)
            .setNamedParameters(Map.of(
                "q", QueryParameterValue.array(q.toArray(new Double[0]), StandardSQLTypeName.FLOAT64),
                "topK", QueryParameterValue.int64(topK),
                "threshold", threshold == null
                    ? QueryParameterValue.nullOf(StandardSQLTypeName.FLOAT64)
                    : QueryParameterValue.float64(threshold)
            ))
            .setPriority(QueryJobConfiguration.Priority.INTERACTIVE)
            .build();

        // Ensure the job runs in the same location as your dataset(s): us-central1
        JobId jobId = JobId.newBuilder().setLocation("us-central1").build();
        Job job = bigQuery.create(JobInfo.newBuilder(qjc).setJobId(jobId).build());

        try {
            job = job.waitFor();
            if (job == null) throw new RuntimeException("Job disappeared");
            if (job.getStatus().getError() != null) {
                throw new RuntimeException(job.getStatus().getError().toString());
            }
            return job.getQueryResults();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }
    }

    private Map<String, Object> parseBaseJson(String json) {
        try {
            @SuppressWarnings("unchecked")
            Map<String, Object> m = om.readValue(json, Map.class);
            // Drop embedding arrays if any slipped through (we kept them out with EXCEPT)
            m.remove("embedding_error");
            m.remove("embedding_solution");
            m.remove("embedding_description");
            m.remove("embedding_notes");
            m.remove("embedding_confluence_data");
            m.remove("embedding_confluence_contacts");
            return m;
        } catch (Exception e) {
            throw new RuntimeException("Failed to parse base_json", e);
        }
    }

    private String summarize(String sourceTable, String id, String name, Map<String, Object> fields) {
        // Prefer *_text from *Text tables; include a fallback to names
        List<String> preferred = switch (sourceTable) {
            case "TableIncidents"  -> List.of("error_text", "solution_text", "incName");
            case "TableIRequests"  -> List.of("description_text", "notes_text", "reqName");
            case "TableConfluence" -> List.of("confluence_data_text", "confluence_contacts_text", "nameConfluence");
            default -> List.of();
        };
        StringBuilder content = new StringBuilder();
        for (String k : preferred) {
            Object v = fields.get(k);
            if (v instanceof String s && !s.isBlank()) {
                content.append(k).append(": ").append(s.length() > 4000 ? s.substring(0, 4000) + "…" : s).append("\n");
            }
        }
        if (content.length() == 0) content.append(fields);

        String system = """
            You are a concise summarizer for incidents/requests/confluence notes.
            Write 1–2 sentences, factual, no speculation. Include identifiers when helpful.
            """;
        String user = "Source=%s, id=%s, name=%s\n\nContent:\n%s".formatted(sourceTable, id, name, content);

        ChatResponse r = chatClient
            .prompt(new SystemMessage(system))
            .prompt(new UserMessage(user))
            .call();

        return r.content();
    }
}

---------------------------------------------------

private Object toJava(FieldValue v, Field f) {
        if (v.isNull()) return null;
        switch (f.getType().getStandardType()) {
            case STRING: return v.getStringValue();
            case BOOL:   return v.getBooleanValue();
            case INT64:  return v.getLongValue();
            case FLOAT64:return v.getDoubleValue();
            case NUMERIC:return v.getNumericValue();
            case JSON:   return v.getStringValue();
            case TIMESTAMP: return v.getTimestampInstant().toString();
            case RECORD:
                Map<String, Object> m = new LinkedHashMap<>();
                FieldList subs = f.getSubFields();
                FieldValueList rec = v.getRecordValue();
                for (int i = 0; i < subs.size(); i++) {
                    m.put(subs.get(i).getName(), toJava(rec.get(i), subs.get(i)));
                }
                return m;
            case ARRAY:
                List<Object> arr = new ArrayList<>();
                Field elem = Field.of(f.getName()+"_elem", f.getType().getArrayElementType());
                for (FieldValue ev : v.getRepeatedValue()) {
                    arr.add(toJava(ev, elem));
                }
                return arr;
            default:
                return v.getStringValue();
        }
    }

---------------------------------------------------    

 // Turn a RECORD into a Map and drop all fields whose top-level name starts with "embedding_"
    private Map<String, Object> toMapDroppingEmbeddings(FieldValue base, FieldList subFields) {
        FieldValueList list = base.getRecordValue();
        Map<String, Object> out = new LinkedHashMap<>();
        for (int i = 0; i < subFields.size(); i++) {
            Field f = subFields.get(i);
            String name = f.getName();
            if (name.startsWith("embedding_")) continue; // drop embeddings
            FieldValue v = list.get(i);
            out.put(name, toJava(v, f));
        }
        return out;
    }

---------------------------------------------------    

<template>
  <v-container class="pa-0 chat-root" fluid>
    <!-- Header -->
    <v-sheet class="px-4 py-3 border-b" elevation="0">
      <div class="text-subtitle-1 font-weight-medium">Assist Chat</div>
    </v-sheet>

    <!-- Messages area -->
    <v-sheet class="messages-wrap" elevation="0">
      <div ref="scrollAreaEl" class="messages">
        <div class="d-flex flex-column" style="gap: 12px;">
          <!-- Bubbles -->
          <template v-for="m in messages" :key="m.id">
            <div
              class="d-flex"
              :class="m.sender === 'user' ? 'justify-end' : 'justify-start'"
            >
              <v-sheet
                class="pa-3 rounded-xl bubble"
                :class="m.sender === 'user' ? 'bubble-user' : 'bubble-bot'"
                elevation="1"
                max-width="80%"
              >
                <!-- If message has a Contacts table, render it -->
                <div v-if="m.table" class="mb-2">
                  <v-table density="comfortable">
                    <thead>
                      <tr>
                        <th v-for="(h, i) in m.table.headers" :key="i" class="text-no-wrap">
                          {{ h }}
                        </th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr v-for="(row, rIdx) in m.table.rows" :key="rIdx">
                        <td v-for="(cell, cIdx) in row" :key="cIdx">
                          {{ cell }}
                        </td>
                      </tr>
                    </tbody>
                  </v-table>
                </div>

                <!-- Otherwise render parsed text/link segments -->
                <template v-else>
                  <template v-for="(seg, idx) in m.segments" :key="idx">
                    <span v-if="seg.type === 'text'">{{ seg.text }}</span>
                    <v-btn
                      v-else
                      variant="text"
                      density="compact"
                      class="text-decoration-underline px-0"
                      @click="onLinkClick((seg as LinkSegment).href)"
                    >
                      {{ (seg as LinkSegment).text }}
                    </v-btn>
                  </template>
                </template>

                <!-- Timestamp -->
                <div class="timestamp">
                  {{ formatTimestamp(m.timestamp) }}
                </div>
              </v-sheet>
            </div>
          </template>

          <!-- Busy indicator -->
          <div v-if="busy" class="d-flex justify-start">
            <v-sheet class="pa-3 rounded-xl bubble bubble-bot" elevation="1" max-width="60%">
              <div class="d-flex align-center" style="gap: 10px;">
                <v-progress-circular indeterminate size="18" width="2" />
                <span>Thinking…</span>
              </div>
            </v-sheet>
          </div>

          <!-- Bottom sentinel to ensure reliable scrolling -->
          <div ref="bottomSentinel" style="height: 1px;"></div>
        </div>
      </div>
    </v-sheet>

    <!-- Sticky input area -->
    <div class="input-sticky">
      <v-divider />
      <v-progress-linear v-if="busy" indeterminate height="3" />
      <v-sheet class="px-3 py-2" elevation="0">
        <v-text-field
          ref="inputRef"
          v-model="draft"
          variant="outlined"
          density="comfortable"
          :disabled="busy"
          :placeholder="busy ? 'Please wait…' : 'Type your message…'"
          hide-details
          clearable
          @keydown.enter="trySend"
          class="ma-0"
        >
          <template #append-inner>
            <v-btn
              icon
              :disabled="busy || !canSend"
              @click="trySend"
              :aria-label="'Send message'"
            >
              <v-icon>mdi-send</v-icon>
            </v-btn>
          </template>
        </v-text-field>
      </v-sheet>
    </div>
  </v-container>
</template>

<script lang="ts">
import { defineComponent, ref, computed, nextTick, watch, onMounted } from 'vue';
import { sendQuery, processChatAction } from './AssistChat';

type Sender = 'user' | 'bot';
type TextSegment = { type: 'text'; text: string };
type LinkSegment = { type: 'link'; text: string; href: string };
type Segment = TextSegment | LinkSegment;

interface TablePayload {
  headers: string[];
  rows: Array<Array<string | number | null>>;
}

interface ChatMessage {
  id: string;
  sender: Sender;
  raw: string;
  segments: Segment[];
  timestamp: Date;
  table?: TablePayload | null; // present only when Contacts JSON detected
}

export default defineComponent({
  name: 'AssistChat',
  setup() {
    const messages = ref<ChatMessage[]>([]);
    const draft = ref('');
    const busy = ref(false);

    // Refs for scrolling & focus
    const scrollAreaEl = ref<HTMLElement | null>(null);
    const bottomSentinel = ref<HTMLElement | null>(null);
    const inputRef = ref<any | null>(null);

    const canSend = computed(() => draft.value.trim().length > 0 && !busy.value);

    function uid(): string {
      return Math.random().toString(36).slice(2, 9);
    }

    function formatTimestamp(d: Date): string {
      return new Intl.DateTimeFormat('en-US', {
        month: '2-digit',
        day: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        hour12: false,
      }).format(d);
    }

    /**
     * Parse <a href="..">text</a> segments from HTMLish strings; plain text otherwise.
     */
    function parseAnchorSegments(htmlish: string): Segment[] {
      const container = document.createElement('div');
      container.innerHTML = htmlish;
      const result: Segment[] = [];

      function walk(node: ChildNode) {
        if (node.nodeType === Node.TEXT_NODE) {
          const text = node.textContent ?? '';
          if (text) result.push({ type: 'text', text });
          return;
        }
        if (node.nodeType === Node.ELEMENT_NODE) {
          const el = node as HTMLElement;
          if (el.tagName.toLowerCase() === 'a') {
            const href = el.getAttribute('href') || '';
            const text = el.textContent?.trim() || href || 'link';
            result.push({ type: 'link', text, href });
            return;
          }
          Array.from(node.childNodes).forEach(walk);
        }
      }
      Array.from(container.childNodes).forEach(walk);
      return result.length ? result : [{ type: 'text', text: htmlish }];
    }

    /**
     * Try to parse a server response string as JSON with the expected Contacts shape.
     * Expected:
     * {
     *   "Contacts": [
     *     { "header1":"Id", "header2":"Name", ... },
     *     { "Id":"1", "Name":"Alice" },
     *     ...
     *   ]
     * }
     */
    function tryParseContactsTable(raw: string): TablePayload | null {
      let obj: any;
      try {
        obj = JSON.parse(raw);
      } catch {
        return null; // not JSON
      }
      if (!obj || typeof obj !== 'object' || !Array.isArray(obj.Contacts) || obj.Contacts.length === 0) {
        return null;
      }
      const arr: any[] = obj.Contacts;

      // First item must be header map: { header1: "Id", header2:"Name", ... }
      const headerMap = arr[0];
      if (!headerMap || typeof headerMap !== 'object') return null;

      // Get header keys ordered by "headerN" (numeric suffix), then map to their values
      const headerKeys = Object.keys(headerMap)
        .sort((a, b) => {
          const na = Number(String(a).replace(/[^\d]/g, '') || '0');
          const nb = Number(String(b).replace(/[^\d]/g, '') || '0');
          return na - nb;
        });

      const headers = headerKeys.map(k => String(headerMap[k] ?? '').trim());

      // Build rows from remaining entries by matching the header names
      const rows: Array<Array<string | number | null>> = [];
      for (let i = 1; i < arr.length; i++) {
        const rowObj = arr[i] ?? {};
        const row = headers.map((h) => {
          const v = rowObj[h];
          return v === undefined ? null : (typeof v === 'object' ? JSON.stringify(v) : v);
        });
        rows.push(row);
      }

      return { headers, rows };
    }

    async function scrollToBottom(smooth = false) {
      await nextTick();
      await new Promise(requestAnimationFrame);

      const sentinel = bottomSentinel.value;
      if (sentinel?.scrollIntoView) {
        sentinel.scrollIntoView({ behavior: smooth ? 'smooth' : 'auto', block: 'end' });
        return;
      }
      const el = scrollAreaEl.value;
      if (!el) return;
      if (typeof (el as any).scrollTo === 'function') {
        (el as any).scrollTo({ top: el.scrollHeight, behavior: smooth ? 'smooth' : 'auto' });
      } else {
        el.scrollTop = el.scrollHeight;
      }
    }

    async function focusInput() {
      await nextTick();
      await new Promise(requestAnimationFrame);
      if (inputRef.value?.focus) {
        inputRef.value.focus();
        return;
      }
      const el: HTMLInputElement | null = inputRef.value?.$el?.querySelector?.('input') ?? null;
      el?.focus();
    }

    function appendMessage(sender: Sender, raw: string) {
      // If bot message, check for Contacts table
      let table: TablePayload | null = null;
      if (sender === 'bot') {
        table = tryParseContactsTable(raw);
      }

      messages.value.push({
        id: uid(),
        sender,
        raw,
        segments: table ? [] : parseAnchorSegments(raw),
        timestamp: new Date(),
        table: table ?? undefined,
      });

      scrollToBottom(sender === 'user');
    }

    function updateResult(response: string) {
      appendMessage('bot', response);
      scrollToBottom(true);
      focusInput();
    }

    async function trySend() {
      if (!canSend.value) return;

      const text = draft.value.trim();
      draft.value = '';
      appendMessage('user', text);

      busy.value = true;
      await scrollToBottom(false);

      try {
        const response = await sendQuery(text);
        updateResult(response);
      } catch (err) {
        updateResult('Sorry, something went wrong.');
        console.error(err);
      } finally {
        busy.value = false;
        focusInput();
      }
    }

    function onLinkClick(href: string) {
      processChatAction(href);
      focusInput();
    }

    // Safety net: auto-scroll on message count changes
    watch(
      () => messages.value.length,
      () => scrollToBottom(false),
    );

    onMounted(() => {
      focusInput();
      scrollToBottom(false);
    });

    return {
      // state
      messages,
      draft,
      busy,
      // refs
      scrollAreaEl,
      bottomSentinel,
      inputRef,
      // computed & methods
      canSend,
      trySend,
      onLinkClick,
      formatTimestamp,
    };
  },
});
</script>

<style scoped>
.chat-root {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  background: #ffffff;
}

.border-b {
  border-bottom: 1px solid rgba(0, 0, 0, 0.08);
}

/* Flex child that allows inner div to scroll */
.messages-wrap {
  flex: 1 1 0;
  min-height: 0;
  background: transparent;
  padding: 0;
}
.messages {
  height: 100%;
  overflow: auto;
  min-height: 0;
  padding: 16px 12px;
}

.input-sticky {
  position: sticky;
  bottom: 0;
  background: #ffffff;
  z-index: 2;
  padding-bottom: env(safe-area-inset-bottom);
}

.bubble {
  white-space: pre-wrap;
  word-break: break-word;
}

/* User bubble = silver */
.bubble-user {
  background-color: silver !important;
  color: rgba(0, 0, 0, 0.87);
}

/* Bot bubble = green */
.bubble-bot {
  background-color: #A5D6A7 !important;
  color: rgba(0, 0, 0, 0.87);
}

.text-decoration-underline {
  text-decoration: underline;
}

.timestamp {
  margin-top: 6px;
  font-size: 0.75rem;
  color: rgba(0, 0, 0, 0.54);
  text-align: right;
}
</style>

---------------------------------------------------    

export async function sendQuery(userText: string): Promise<string> {
  await new Promise((r) => setTimeout(r, 1000));
  if (userText.trim().toLowerCase().includes('contacts')) {
    return JSON.stringify({
      Contacts: [
        { header1: "Id", header2: "Name", header3: "Email" },
        { Id: "101", Name: "Alice", Email: "alice@example.com" },
        { Id: "102", Name: "Bob",   Email: "bob@example.com" }
      ]
    });
  }
  // ...your other branches...
  return `Hello! See <a href="https://vuetifyjs.com/en/components/tables/">Vuetify tables</a>`;
}
